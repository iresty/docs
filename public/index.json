[
{
	"uri": "/docs/",
	"title": "OpenResty 相关文档",
	"tags": [],
	"description": "",
	"content": " lua-resty-memcached lua-resty-mysql lua-resty-redis lua-resty-dns lua-resty-upload lua-resty-websocket lua-resty-lock lua-resty-logger-socket lua-resty-lrucache lua-resty-string ngx_memc ngx_postgres ngx_redis2 ngx_redis ngx_proxy [ngx_fastcgi](http://nginx.org/en/docs/http/ngx  "
},
{
	"uri": "/",
	"title": "test",
	"tags": [],
	"description": "",
	"content": " 云原生网关  lua-resty-lock lua-resty-logger-socket lua-resty-lrucache lua-resty-string ngx_memc ngx_postgres ngx_redis2 ngx_redis [ngx_proxy](http://nginx.org/en/docs/http/ngx_http_proxy_module.html  "
},
{
	"uri": "/apisix/",
	"title": "APISIX",
	"tags": [],
	"description": "",
	"content": " wed： 技术\n Synopsis Description Typical Uses Nginx Compatibility Installation  Building as a dynamic module C Macro Configurations  Community  English Mailing List Chinese Mailing List  Code Repository Bugs and Patches Lua/LuaJIT bytecode support System Environment Variable Support HTTP 1.0 support Statically Linking Pure Lua Modules Data Sharing within an Nginx Worker Known Issues  TCP socket connect operation issues Lua Coroutine Yielding/Resuming Lua Variable Scope Locations Configured by Subrequest Directives of Other Modules Cosockets Not Available Everywhere Special Escaping Sequences Mixing with SSI Not Supported SPDY Mode Not Fully Supported Missing data on short circuited requests  TODO Changes Test Suite Copyright and License See Also Directives Nginx API for Lua Obsolete Sections  Special PCRE Sequences   "
},
{
	"uri": "/apisix/quickstart/",
	"title": "Quickstart",
	"tags": [],
	"description": "",
	"content": " xx "
},
{
	"uri": "/categories/apisix/",
	"title": "APISIX",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/docs/openresty-doc/",
	"title": "lua-nginx-module",
	"tags": ["xxxxx"],
	"description": "",
	"content": " Name ngx_http_lua_module - Embed the power of Lua into Nginx HTTP Servers.\nThis module is a core component of OpenResty. If you are using this module, then you are essentially using OpenResty :)\nThis module is not distributed with the Nginx source. See the installation instructions.\nTable of Contents  Name Status Version Synopsis Description Typical Uses Nginx Compatibility Installation  Building as a dynamic module C Macro Configurations  Community  English Mailing List Chinese Mailing List  Code Repository Bugs and Patches Lua/LuaJIT bytecode support System Environment Variable Support HTTP 1.0 support Statically Linking Pure Lua Modules Data Sharing within an Nginx Worker Known Issues  TCP socket connect operation issues Lua Coroutine Yielding/Resuming Lua Variable Scope Locations Configured by Subrequest Directives of Other Modules Cosockets Not Available Everywhere Special Escaping Sequences Mixing with SSI Not Supported SPDY Mode Not Fully Supported Missing data on short circuited requests  TODO Changes Test Suite Copyright and License See Also Directives Nginx API for Lua Obsolete Sections  Special PCRE Sequences   Status Production ready.\nVersion This document describes ngx_lua v0.10.16, which is not released yet.\nSynopsis # set search paths for pure Lua external libraries (\u0026#39;;;\u0026#39; is the default path):  lua_package_path \u0026#39;/foo/bar/?.lua;/blah/?.lua;;\u0026#39;; # set search paths for Lua external libraries written in C (can also use \u0026#39;;;\u0026#39;):  lua_package_cpath \u0026#39;/bar/baz/?.so;/blah/blah/?.so;;\u0026#39;; server { location /lua_content { # MIME type determined by default_type:  default_type \u0026#39;text/plain\u0026#39;; content_by_lua_block { ngx.say(\u0026#39;Hello,world!\u0026#39;) } } location /nginx_var { # MIME type determined by default_type:  default_type \u0026#39;text/plain\u0026#39;; # try access /nginx_var?a=hello,world  content_by_lua_block { ngx.say(ngx.var.arg_a) } } location = /request_body { client_max_body_size 50k; client_body_buffer_size 50k; content_by_lua_block { ngx.req.read_body() -- explicitly read the req body local data = ngx.req.get_body_data() if data then ngx.say(\u0026#34;body data:\u0026#34;) ngx.print(data) return end -- body may get buffered in a temp file: local file = ngx.req.get_body_file() if file then ngx.say(\u0026#34;body is in file \u0026#34;, file) else ngx.say(\u0026#34;no body found\u0026#34;) end } } # transparent non-blocking I/O in Lua via subrequests  # (well, a better way is to use cosockets)  location = /lua { # MIME type determined by default_type:  default_type \u0026#39;text/plain\u0026#39;; content_by_lua_block { local res = ngx.location.capture(\u0026#34;/some_other_location\u0026#34;) if res then ngx.say(\u0026#34;status: \u0026#34;, res.status) ngx.say(\u0026#34;body:\u0026#34;) ngx.print(res.body) end } } location = /foo { rewrite_by_lua_block { res = ngx.location.capture(\u0026#34;/memc\u0026#34;, { args = { cmd = \u0026#34;incr\u0026#34;, key = ngx.var.uri } } ) } proxy_pass http://blah.blah.com; } location = /mixed { rewrite_by_lua_file /path/to/rewrite.lua; access_by_lua_file /path/to/access.lua; content_by_lua_file /path/to/content.lua; } # use nginx var in code path  # CAUTION: contents in nginx var must be carefully filtered,  # otherwise there\u0026#39;ll be great security risk!  location ~ ^/app/([-_a-zA-Z0-9/]+) { set $path $1; content_by_lua_file /path/to/lua/app/root/$path.lua; } location / { client_max_body_size 100k; client_body_buffer_size 100k; access_by_lua_block { -- check the client IP address is in our black list if ngx.var.remote_addr == \u0026#34;132.5.72.3\u0026#34; then ngx.exit(ngx.HTTP_FORBIDDEN) end -- check if the URI contains bad words if ngx.var.uri and string.match(ngx.var.request_body, \u0026#34;evil\u0026#34;) then return ngx.redirect(\u0026#34;/terms_of_use.html\u0026#34;) end -- tests passed } # proxy_pass/fastcgi_pass/etc settings  } } Back to TOC\nDescription This module is a core component of OpenResty. If you are using this module, then you are essentially using OpenResty :)\nThis module embeds Lua, via LuaJIT 2.0/2.1, into Nginx and by leveraging Nginx\u0026rsquo;s subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.\nUnlike Apache\u0026rsquo;s mod_lua and Lighttpd\u0026rsquo;s mod_magnet, Lua code executed using this module can be 100% non-blocking on network traffic as long as the Nginx API for Lua provided by this module is used to handle requests to upstream services such as MySQL, PostgreSQL, Memcached, Redis, or upstream HTTP web services.\nAt least the following Lua libraries and Nginx modules can be used with this ngx_lua module:\n lua-resty-memcached lua-resty-mysql lua-resty-redis lua-resty-dns lua-resty-upload lua-resty-websocket lua-resty-lock lua-resty-logger-socket lua-resty-lrucache lua-resty-string ngx_memc ngx_postgres ngx_redis2 ngx_redis ngx_proxy ngx_fastcgi  Almost all the Nginx modules can be used with this ngx_lua module by means of ngx.location.capture or ngx.location.capture_multi but it is recommended to use those lua-resty-* libraries instead of creating subrequests to access the Nginx upstream modules because the former is usually much more flexible and memory-efficient.\nThe Lua interpreter or LuaJIT instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight Lua coroutines.\nLoaded Lua modules persist in the nginx worker process level resulting in a small memory footprint in Lua even when under heavy loads.\nThis module is plugged into NGINX\u0026rsquo;s \u0026ldquo;http\u0026rdquo; subsystem so it can only speaks downstream communication protocols in the HTTP family (HTTP 0.9\u0026frasl;1.0/1.1\u0026frasl;2.0, WebSockets, and etc). If you want to do generic TCP communications with the downstream clients, then you should use the ngx_stream_lua module instead which has a compatible Lua API.\nBack to TOC\nTypical Uses Just to name a few:\n Mashup\u0026rsquo;ing and processing outputs of various nginx upstream outputs (proxy, drizzle, postgres, redis, memcached, and etc) in Lua, doing arbitrarily complex access control and security checks in Lua before requests actually reach the upstream backends, manipulating response headers in an arbitrary way (by Lua) fetching backend information from external storage backends (like redis, memcached, mysql, postgresql) and use that information to choose which upstream backend to access on-the-fly, coding up arbitrarily complex web applications in a content handler using synchronous but still non-blocking access to the database backends and other storage, doing very complex URL dispatch in Lua at rewrite phase, using Lua to implement advanced caching mechanism for Nginx\u0026rsquo;s subrequests and arbitrary locations.  The possibilities are unlimited as the module allows bringing together various elements within Nginx as well as exposing the power of the Lua language to the user. The module provides the full flexibility of scripting while offering performance levels comparable with native C language programs both in terms of CPU time as well as memory footprint. This is particularly the case when LuaJIT 2.x is enabled.\nOther scripting language implementations typically struggle to match this performance level.\nThe Lua state (Lua VM instance) is shared across all the requests handled by a single nginx worker process to minimize memory use.\nBack to TOC\nNginx Compatibility The latest version of this module is compatible with the following versions of Nginx:\n 1.15.x (last tested: 1.15.8) 1.14.x 1.13.x (last tested: 1.13.6) 1.12.x 1.11.x (last tested: 1.11.2) 1.10.x 1.9.x (last tested: 1.9.15) 1.8.x 1.7.x (last tested: 1.7.10) 1.6.x  Nginx cores older than 1.6.0 (exclusive) are not supported.\nBack to TOC\nInstallation It is highly recommended to use OpenResty releases which integrate Nginx, ngx_lua, OpenResty\u0026rsquo;s LuaJIT 2.1 branch version, as well as other powerful companion Nginx modules and Lua libraries. It is discouraged to build this module with nginx yourself since it is tricky to set up exactly right. Also, the stock nginx cores have various limitations and long standing bugs that can make some of this modules\u0026rsquo; features become disabled, not work properly, or run slower. The same applies to LuaJIT as well. OpenResty includes its own version of LuaJIT which gets specifically optimized and enhanced for the OpenResty environment.\nAlternatively, ngx_lua can be manually compiled into Nginx:\n LuaJIT can be downloaded from the latest release of OpenResty\u0026rsquo;s LuaJIT branch version. The official LuaJIT 2.0 and 2.1 releases are also supported, although the performance will be significantly lower in many cases. Download the latest version of the ngx_devel_kit (NDK) module HERE. Download the latest version of ngx_lua HERE. Download the latest version of Nginx HERE (See Nginx Compatibility)  Build the source with this module:\nwget \u0026#39;http://nginx.org/download/nginx-1.13.6.tar.gz\u0026#39; tar -xzvf nginx-1.13.6.tar.gz cd nginx-1.13.6/ # tell nginx\u0026#39;s build system where to find LuaJIT 2.0: export LUAJIT_LIB=/path/to/luajit/lib export LUAJIT_INC=/path/to/luajit/include/luajit-2.0 # tell nginx\u0026#39;s build system where to find LuaJIT 2.1: export LUAJIT_LIB=/path/to/luajit/lib export LUAJIT_INC=/path/to/luajit/include/luajit-2.1 # or tell where to find Lua if using Lua instead: #export LUA_LIB=/path/to/lua/lib #export LUA_INC=/path/to/lua/include # Here we assume Nginx is to be installed under /opt/nginx/. ./configure --prefix=/opt/nginx \\  --with-ld-opt=\u0026#34;-Wl,-rpath,/path/to/luajit-or-lua/lib\u0026#34; \\  --add-module=/path/to/ngx_devel_kit \\  --add-module=/path/to/lua-nginx-module # Note that you may also want to add `./configure` options which are used in your # current nginx build. # You can get usually those options using command nginx -V # you can change the parallism number 2 below to fit the number of spare CPU cores in your # machine. make -j2 make install Back to TOC\nBuilding as a dynamic module Starting from NGINX 1.9.11, you can also compile this module as a dynamic module, by using the --add-dynamic-module=PATH option instead of --add-module=PATH on the ./configure command line above. And then you can explicitly load the module in your nginx.conf via the load_module directive, for example,\nload_module /path/to/modules/ndk_http_module.so; # assuming NDK is built as a dynamic module too  load_module /path/to/modules/ngx_http_lua_module.so; Back to TOC\nC Macro Configurations While building this module either via OpenResty or with the NGINX core, you can define the following C macros via the C compiler options:\n NGX_LUA_USE_ASSERT When defined, will enable assertions in the ngx_lua C code base. Recommended for debugging or testing builds. It can introduce some (small) runtime overhead when enabled. This macro was first introduced in the v0.9.10 release. NGX_LUA_ABORT_AT_PANIC When the Lua/LuaJIT VM panics, ngx_lua will instruct the current nginx worker process to quit gracefully by default. By specifying this C macro, ngx_lua will abort the current nginx worker process (which usually result in a core dump file) immediately. This option is useful for debugging VM panics. This option was first introduced in the v0.9.8 release. NGX_LUA_NO_FFI_API Excludes pure C API functions for FFI-based Lua API for NGINX (as required by lua-resty-core, for example). Enabling this macro can make the resulting binary code size smaller.  To enable one or more of these macros, just pass extra C compiler options to the ./configure script of either NGINX or OpenResty. For instance,\n./configure --with-cc-opt=\u0026quot;-DNGX_LUA_USE_ASSERT -DNGX_LUA_ABORT_AT_PANIC\u0026quot;  Back to TOC\nCommunity Back to TOC\nEnglish Mailing List The openresty-en mailing list is for English speakers.\nBack to TOC\nChinese Mailing List The openresty mailing list is for Chinese speakers.\nBack to TOC\nCode Repository The code repository of this project is hosted on github at openresty/lua-nginx-module.\nBack to TOC\nBugs and Patches Please submit bug reports, wishlists, or patches by\n creating a ticket on the GitHub Issue Tracker, or posting to the OpenResty community.  Back to TOC\nLua/LuaJIT bytecode support As from the v0.5.0rc32 release, all *_by_lua_file configure directives (such as content_by_lua_file) support loading Lua 5.1 and LuaJIT 2.0/2.1 raw bytecode files directly.\nPlease note that the bytecode format used by LuaJIT 2.0/2.1 is not compatible with that used by the standard Lua 5.1 interpreter. So if you are using LuaJIT 2.0/2.1 with ngx_lua, LuaJIT compatible bytecode files must be generated as shown:\n/path/to/luajit/bin/luajit -b /path/to/input_file.lua /path/to/output_file.ljbc The -bg option can be used to include debug information in the LuaJIT bytecode file:\n/path/to/luajit/bin/luajit -bg /path/to/input_file.lua /path/to/output_file.ljbc Please refer to the official LuaJIT documentation on the -b option for more details:\nhttp://luajit.org/running.html#opt_b\nAlso, the bytecode files generated by LuaJIT 2.1 is not compatible with LuaJIT 2.0, and vice versa. The support for LuaJIT 2.1 bytecode was first added in ngx_lua v0.9.3.\nAttempts to load standard Lua 5.1 bytecode files into ngx_lua instances linked to LuaJIT 2.0/2.1 or vice versa, will result in an error message, such as that below, being logged into the Nginx error.log file:\n[error] 13909#0: *1 failed to load Lua inlined code: bad byte-code header in /path/to/test_file.luac  Loading bytecode files via the Lua primitives like require and dofile should always work as expected.\nBack to TOC\nSystem Environment Variable Support If you want to access the system environment variable, say, foo, in Lua via the standard Lua API os.getenv, then you should also list this environment variable name in your nginx.conf file via the env directive. For example,\nenv foo; Back to TOC\nHTTP 1.0 support The HTTP 1.0 protocol does not support chunked output and requires an explicit Content-Length header when the response body is not empty in order to support the HTTP 1.0 keep-alive. So when a HTTP 1.0 request is made and the lua_http10_buffering directive is turned on, ngx_lua will buffer the output of ngx.say and ngx.print calls and also postpone sending response headers until all the response body output is received. At that time ngx_lua can calculate the total length of the body and construct a proper Content-Length header to return to the HTTP 1.0 client. If the Content-Length response header is set in the running Lua code, however, this buffering will be disabled even if the lua_http10_buffering directive is turned on.\nFor large streaming output responses, it is important to disable the lua_http10_buffering directive to minimise memory usage.\nNote that common HTTP benchmark tools such as ab and http_load issue HTTP 1.0 requests by default. To force curl to send HTTP 1.0 requests, use the -0 option.\nBack to TOC\nStatically Linking Pure Lua Modules When LuaJIT 2.x is used, it is possible to statically link the bytecode of pure Lua modules into the Nginx executable.\nBasically you use the luajit executable to compile .lua Lua module files to .o object files containing the exported bytecode data, and then link the .o files directly in your Nginx build.\nBelow is a trivial example to demonstrate this. Consider that we have the following .lua file named foo.lua:\n-- foo.lua local _M = {} function _M.go() print(\u0026#34;Hello from foo\u0026#34;) end return _M And then we compile this .lua file to foo.o file:\n/path/to/luajit/bin/luajit -bg foo.lua foo.o  What matters here is the name of the .lua file, which determines how you use this module later on the Lua land. The file name foo.o does not matter at all except the .o file extension (which tells luajit what output format is used). If you want to strip the Lua debug information from the resulting bytecode, you can just specify the -b option above instead of -bg.\nThen when building Nginx or OpenResty, pass the --with-ld-opt=\u0026quot;foo.o\u0026quot; option to the ./configure script:\n./configure --with-ld-opt=\u0026#34;/path/to/foo.o\u0026#34; ... Finally, you can just do the following in any Lua code run by ngx_lua:\nlocal foo = require \u0026#34;foo\u0026#34; foo.go() And this piece of code no longer depends on the external foo.lua file any more because it has already been compiled into the nginx executable.\nIf you want to use dot in the Lua module name when calling require, as in\nlocal foo = require \u0026#34;resty.foo\u0026#34; then you need to rename the foo.lua file to resty_foo.lua before compiling it down to a .o file with the luajit command-line utility.\nIt is important to use exactly the same version of LuaJIT when compiling .lua files to .o files as building nginx + ngx_lua. This is because the LuaJIT bytecode format may be incompatible between different LuaJIT versions. When the bytecode format is incompatible, you will see a Lua runtime error saying that the Lua module is not found.\nWhen you have multiple .lua files to compile and link, then just specify their .o files at the same time in the value of the --with-ld-opt option. For instance,\n./configure --with-ld-opt=\u0026#34;/path/to/foo.o /path/to/bar.o\u0026#34; ... If you have just too many .o files, then it might not be feasible to name them all in a single command. In this case, you can build a static library (or archive) for your .o files, as in\nar rcus libmyluafiles.a *.o then you can link the myluafiles archive as a whole to your nginx executable:\n./configure \\  --with-ld-opt=\u0026#34;-L/path/to/lib -Wl,--whole-archive -lmyluafiles -Wl,--no-whole-archive\u0026#34; where /path/to/lib is the path of the directory containing the libmyluafiles.a file. It should be noted that the linker option --whole-archive is required here because otherwise our archive will be skipped because no symbols in our archive are mentioned in the main parts of the nginx executable.\nBack to TOC\nData Sharing within an Nginx Worker To globally share data among all the requests handled by the same nginx worker process, encapsulate the shared data into a Lua module, use the Lua require builtin to import the module, and then manipulate the shared data in Lua. This works because required Lua modules are loaded only once and all coroutines will share the same copy of the module (both its code and data). Note however that Lua global variables (note, not module-level variables) WILL NOT persist between requests because of the one-coroutine-per-request isolation design.\nHere is a complete small example:\n-- mydata.lua local _M = {} local data = { dog = 3, cat = 4, pig = 5, } function _M.get_age(name) return data[name] end return _M and then accessing it from nginx.conf:\nlocation /lua { content_by_lua_block { local mydata = require \u0026#34;mydata\u0026#34; ngx.say(mydata.get_age(\u0026#34;dog\u0026#34;)) } } The mydata module in this example will only be loaded and run on the first request to the location /lua, and all subsequent requests to the same nginx worker process will use the reloaded instance of the module as well as the same copy of the data in it, until a HUP signal is sent to the Nginx master process to force a reload. This data sharing technique is essential for high performance Lua applications based on this module.\nNote that this data sharing is on a per-worker basis and not on a per-server basis. That is, when there are multiple nginx worker processes under an Nginx master, data sharing cannot cross the process boundary between these workers.\nIt is usually recommended to share read-only data this way. You can also share changeable data among all the concurrent requests of each nginx worker process as long as there is no nonblocking I/O operations (including ngx.sleep) in the middle of your calculations. As long as you do not give the control back to the nginx event loop and ngx_lua\u0026rsquo;s light thread scheduler (even implicitly), there can never be any race conditions in between. For this reason, always be very careful when you want to share changeable data on the worker level. Buggy optimizations can easily lead to hard-to-debug race conditions under load.\nIf server-wide data sharing is required, then use one or more of the following approaches:\n Use the ngx.shared.DICT API provided by this module. Use only a single nginx worker and a single server (this is however not recommended when there is a multi core CPU or multiple CPUs in a single machine). Use data storage mechanisms such as memcached, redis, MySQL or PostgreSQL. The OpenResty bundle associated with this module comes with a set of companion Nginx modules and Lua libraries that provide interfaces with these data storage mechanisms.  Back to TOC\nKnown Issues Back to TOC\nTCP socket connect operation issues The tcpsock:connect method may indicate success despite connection failures such as with Connection Refused errors.\nHowever, later attempts to manipulate the cosocket object will fail and return the actual error status message generated by the failed connect operation.\nThis issue is due to limitations in the Nginx event model and only appears to affect Mac OS X.\nBack to TOC\nLua Coroutine Yielding/Resuming  Because Lua\u0026rsquo;s dofile and require builtins are currently implemented as C functions in LuaJIT 2.0/2.1, if the Lua file being loaded by dofile or require invokes ngx.location.capture*, ngx.exec, ngx.exit, or other API functions requiring yielding in the top-level scope of the Lua file, then the Lua error \u0026ldquo;attempt to yield across C-call boundary\u0026rdquo; will be raised. To avoid this, put these calls requiring yielding into your own Lua functions in the Lua file instead of the top-level scope of the file.  Back to TOC\nLua Variable Scope Care must be taken when importing modules and this form should be used:\nlocal xxx = require(\u0026#39;xxx\u0026#39;) instead of the old deprecated form:\nrequire(\u0026#39;xxx\u0026#39;) Here is the reason: by design, the global environment has exactly the same lifetime as the Nginx request handler associated with it. Each request handler has its own set of Lua global variables and that is the idea of request isolation. The Lua module is actually loaded by the first Nginx request handler and is cached by the require() built-in in the package.loaded table for later reference, and the module() builtin used by some Lua modules has the side effect of setting a global variable to the loaded module table. But this global variable will be cleared at the end of the request handler, and every subsequent request handler all has its own (clean) global environment. So one will get Lua exception for accessing the nil value.\nThe use of Lua global variables is a generally inadvisable in the ngx_lua context as:\n the misuse of Lua globals has detrimental side effects on concurrent requests when such variables should instead be local in scope, Lua global variables require Lua table look-ups in the global environment which is computationally expensive, and some Lua global variable references may include typing errors which make such difficult to debug.  It is therefore highly recommended to always declare such within an appropriate local scope instead.\n-- Avoid foo = 123 -- Recommended local foo = 123 -- Avoid function foo() return 123 end -- Recommended local function foo() return 123 end To find all instances of Lua global variables in your Lua code, run the lua-releng tool across all .lua source files:\n$ lua-releng Checking use of Lua global variables in file lib/foo/bar.lua ... 1 [1489] SETGLOBAL 7 -1 ; contains 55 [1506] GETGLOBAL 7 -3 ; setvar 3 [1545] GETGLOBAL 3 -4 ; varexpand  The output says that the line 1489 of file lib/foo/bar.lua writes to a global variable named contains, the line 1506 reads from the global variable setvar, and line 1545 reads the global varexpand.\nThis tool will guarantee that local variables in the Lua module functions are all declared with the local keyword, otherwise a runtime exception will be thrown. It prevents undesirable race conditions while accessing such variables. See Data Sharing within an Nginx Worker for the reasons behind this.\nBack to TOC\nLocations Configured by Subrequest Directives of Other Modules The ngx.location.capture and ngx.location.capture_multi directives cannot capture locations that include the add_before_body, add_after_body, auth_request, echo_location, echo_location_async, echo_subrequest, or echo_subrequest_async directives.\nlocation /foo { content_by_lua_block { res = ngx.location.capture(\u0026#34;/bar\u0026#34;) } } location /bar { echo_location /blah; } location /blah { echo \u0026#34;Success!\u0026#34;; }$ curl -i http://example.com/foo will not work as expected.\nBack to TOC\nCosockets Not Available Everywhere Due to internal limitations in the nginx core, the cosocket API is disabled in the following contexts: set_by_lua*, log_by_lua*, header_filter_by_lua*, and body_filter_by_lua.\nThe cosockets are currently also disabled in the init_by_lua* and init_worker_by_lua* directive contexts but we may add support for these contexts in the future because there is no limitation in the nginx core (or the limitation might be worked around).\nThere exists a work-around, however, when the original context does not need to wait for the cosocket results. That is, creating a zero-delay timer via the ngx.timer.at API and do the cosocket results in the timer handler, which runs asynchronously as to the original context creating the timer.\nBack to TOC\nSpecial Escaping Sequences NOTE Following the v0.9.17 release, this pitfall can be avoided by using the *_by_lua_block {} configuration directives.\nPCRE sequences such as \\d, \\s, or \\w, require special attention because in string literals, the backslash character, \\, is stripped out by both the Lua language parser and by the nginx config file parser before processing if not within a *_by_lua_block {} directive. So the following snippet will not work as expected:\n# nginx.conf  ? location /test { ? content_by_lua \u0026#39; ? local regex = \u0026#34;\\d+\u0026#34; -- THIS IS WRONG OUTSIDE OF A *_by_lua_block DIRECTIVE ? local m = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, regex) ? if m then ngx.say(m[0]) else ngx.say(\u0026#34;not matched!\u0026#34;) end ? \u0026#39;; ? } # evaluates to \u0026#34;not matched!\u0026#34; To avoid this, double escape the backslash:\n# nginx.conf  location /test { content_by_lua \u0026#39; local regex = \u0026#34;\\\\\\\\d+\u0026#34; local m = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, regex) if m then ngx.say(m[0]) else ngx.say(\u0026#34;not matched!\u0026#34;) end \u0026#39;; } # evaluates to \u0026#34;1234\u0026#34; Here, \\\\\\\\d+ is stripped down to \\\\d+ by the Nginx config file parser and this is further stripped down to \\d+ by the Lua language parser before running.\nAlternatively, the regex pattern can be presented as a long-bracketed Lua string literal by encasing it in \u0026ldquo;long brackets\u0026rdquo;, [[...]], in which case backslashes have to only be escaped once for the Nginx config file parser.\n# nginx.conf  location /test { content_by_lua \u0026#39; local regex = [[\\\\d+]] local m = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, regex) if m then ngx.say(m[0]) else ngx.say(\u0026#34;not matched!\u0026#34;) end \u0026#39;; } # evaluates to \u0026#34;1234\u0026#34; Here, [[\\\\d+]] is stripped down to [[\\d+]] by the Nginx config file parser and this is processed correctly.\nNote that a longer from of the long bracket, [=[...]=], may be required if the regex pattern contains [...] sequences. The [=[...]=] form may be used as the default form if desired.\n# nginx.conf  location /test { content_by_lua \u0026#39; local regex = [=[[0-9]+]=] local m = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, regex) if m then ngx.say(m[0]) else ngx.say(\u0026#34;not matched!\u0026#34;) end \u0026#39;; } # evaluates to \u0026#34;1234\u0026#34; An alternative approach to escaping PCRE sequences is to ensure that Lua code is placed in external script files and executed using the various *_by_lua_file directives. With this approach, the backslashes are only stripped by the Lua language parser and therefore only need to be escaped once each.\n-- test.lua local regex = \u0026#34;\\\\d+\u0026#34; local m = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, regex) if m then ngx.say(m[0]) else ngx.say(\u0026#34;not matched!\u0026#34;) end -- evaluates to \u0026#34;1234\u0026#34; Within external script files, PCRE sequences presented as long-bracketed Lua string literals do not require modification.\n-- test.lua local regex = [[\\d+]] local m = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, regex) if m then ngx.say(m[0]) else ngx.say(\u0026#34;not matched!\u0026#34;) end -- evaluates to \u0026#34;1234\u0026#34; As noted earlier, PCRE sequences presented within *_by_lua_block {} directives (available following the v0.9.17 release) do not require modification.\n# nginx.conf  location /test { content_by_lua_block { local regex = [[\\d+]] local m = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, regex) if m then ngx.say(m[0]) else ngx.say(\u0026#34;not matched!\u0026#34;) end } } # evaluates to \u0026#34;1234\u0026#34; Back to TOC\nMixing with SSI Not Supported Mixing SSI with ngx_lua in the same Nginx request is not supported at all. Just use ngx_lua exclusively. Everything you can do with SSI can be done atop ngx_lua anyway and it can be more efficient when using ngx_lua.\nBack to TOC\nSPDY Mode Not Fully Supported Certain Lua APIs provided by ngx_lua do not work in Nginx\u0026rsquo;s SPDY mode yet: ngx.location.capture, ngx.location.capture_multi, and ngx.req.socket.\nBack to TOC\nMissing data on short circuited requests Nginx may terminate a request early with (at least):\n 400 (Bad Request) 405 (Not Allowed) 408 (Request Timeout) 413 (Request Entity Too Large) 414 (Request URI Too Large) 494 (Request Headers Too Large) 499 (Client Closed Request) 500 (Internal Server Error) 501 (Not Implemented)  This means that phases that normally run are skipped, such as the rewrite or access phase. This also means that later phases that are run regardless, e.g. log_by_lua, will not have access to information that is normally set in those phases.\nBack to TOC\nTODO  cosocket: implement LuaSocket\u0026rsquo;s unconnected UDP API. port this module to the \u0026ldquo;datagram\u0026rdquo; subsystem of NGINX for implementing general UDP servers instead of HTTP servers in Lua. For example, ```lua  datagram { server { listen 1953; handler_by_lua_block { \u0026ndash; custom Lua code implementing the special UDP server\u0026hellip; } } }\n* shm: implement a \u0026quot;shared queue API\u0026quot; to complement the existing [shared dict](#lua_shared_dict) API. * cosocket: add support in the context of [init_by_lua*](#init_by_lua). * cosocket: implement the `bind()` method for stream-typed cosockets. * cosocket: pool-based backend concurrency level control: implement automatic `connect` queueing when the backend concurrency exceeds its connection pool limit. * cosocket: review and merge aviramc's [patch](https://github.com/openresty/lua-nginx-module/pull/290) for adding the `bsdrecv` method. * add new API function `ngx.resp.add_header` to emulate the standard `add_header` config directive. * review and apply vadim-pavlov's patch for [ngx.location.capture](#ngxlocationcapture)'s `extra_headers` option * use `ngx_hash_t` to optimize the built-in header look-up process for [ngx.req.set_header](#ngxreqset_header), [ngx.header.HEADER](#ngxheaderheader), and etc. * add configure options for different strategies of handling the cosocket connection exceeding in the pools. * add directives to run Lua codes when nginx stops. * add `ignore_resp_headers`, `ignore_resp_body`, and `ignore_resp` options to [ngx.location.capture](#ngxlocationcapture) and [ngx.location.capture_multi](#ngxlocationcapture_multi) methods, to allow micro performance tuning on the user side. * add automatic Lua code time slicing support by yielding and resuming the Lua VM actively via Lua's debug hooks. * add `stat` mode similar to [mod_lua](https://httpd.apache.org/docs/trunk/mod/mod_lua.html). * cosocket: add client SSL certificate support. [Back to TOC](#table-of-contents) Changes ======= The changes made in every release of this module are listed in the change logs of the OpenResty bundle: \u0026lt;http://openresty.org/#Changes\u0026gt; [Back to TOC](#table-of-contents) Test Suite ========== The following dependencies are required to run the test suite: * Nginx version \u0026gt;= 1.4.2 * Perl modules: * Test::Nginx: \u0026lt;https://github.com/openresty/test-nginx\u0026gt; * Nginx modules: * [ngx_devel_kit](https://github.com/simplresty/ngx_devel_kit) * [ngx_set_misc](https://github.com/openresty/set-misc-nginx-module) * [ngx_auth_request](http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz) (this is not needed if you're using Nginx 1.5.4+. * [ngx_echo](https://github.com/openresty/echo-nginx-module) * [ngx_memc](https://github.com/openresty/memc-nginx-module) * [ngx_srcache](https://github.com/openresty/srcache-nginx-module) * ngx_lua (i.e., this module) * [ngx_lua_upstream](https://github.com/openresty/lua-upstream-nginx-module) * [ngx_headers_more](https://github.com/openresty/headers-more-nginx-module) * [ngx_drizzle](https://github.com/openresty/drizzle-nginx-module) * [ngx_rds_json](https://github.com/openresty/rds-json-nginx-module) * [ngx_coolkit](https://github.com/FRiCKLE/ngx_coolkit) * [ngx_redis2](https://github.com/openresty/redis2-nginx-module) The order in which these modules are added during configuration is important because the position of any filter module in the filtering chain determines the final output, for example. The correct adding order is shown above. * 3rd-party Lua libraries: * [lua-cjson](http://www.kyne.com.au/~mark/software/lua-cjson.php) * Applications: * mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test' * memcached: listening on the default port, 11211. * redis: listening on the default port, 6379. See also the [developer build script](https://github.com/openresty/lua-nginx-module/blob/master/util/build.sh) for more details on setting up the testing environment. To run the whole test suite in the default testing mode: cd /path/to/lua-nginx-module export PATH=/path/to/your/nginx/sbin:$PATH prove -I/path/to/test-nginx/lib -r t To run specific test files: cd /path/to/lua-nginx-module export PATH=/path/to/your/nginx/sbin:$PATH prove -I/path/to/test-nginx/lib t/002-content.t t/003-errors.t To run a specific test block in a particular test file, add the line `--- ONLY` to the test block you want to run, and then use the `prove` utility to run that `.t` file. There are also various testing modes based on mockeagain, valgrind, and etc. Refer to the [Test::Nginx documentation](http://search.cpan.org/perldoc?Test::Nginx) for more details for various advanced testing modes. See also the test reports for the Nginx test cluster running on Amazon EC2: \u0026lt;http://qa.openresty.org\u0026gt;. [Back to TOC](#table-of-contents) Copyright and License ===================== This module is licensed under the BSD license. Copyright (C) 2009-2017, by Xiaozhe Wang (chaoslawful) \u0026lt;chaoslawful@gmail.com\u0026gt;. Copyright (C) 2009-2019, by Yichun \u0026quot;agentzh\u0026quot; Zhang (章亦春) \u0026lt;agentzh@gmail.com\u0026gt;, OpenResty Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0026quot;AS IS\u0026quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. [Back to TOC](#table-of-contents) See Also ======== * [ngx_stream_lua_module](https://github.com/openresty/stream-lua-nginx-module#readme) for an official port of this module for the NGINX \u0026quot;stream\u0026quot; subsystem (doing generic downstream TCP communications). * [lua-resty-memcached](https://github.com/openresty/lua-resty-memcached) library based on ngx_lua cosocket. * [lua-resty-redis](https://github.com/openresty/lua-resty-redis) library based on ngx_lua cosocket. * [lua-resty-mysql](https://github.com/openresty/lua-resty-mysql) library based on ngx_lua cosocket. * [lua-resty-upload](https://github.com/openresty/lua-resty-upload) library based on ngx_lua cosocket. * [lua-resty-dns](https://github.com/openresty/lua-resty-dns) library based on ngx_lua cosocket. * [lua-resty-websocket](https://github.com/openresty/lua-resty-websocket) library for both WebSocket server and client, based on ngx_lua cosocket. * [lua-resty-string](https://github.com/openresty/lua-resty-string) library based on [LuaJIT FFI](http://luajit.org/ext_ffi.html). * [lua-resty-lock](https://github.com/openresty/lua-resty-lock) library for a nonblocking simple lock API. * [lua-resty-cookie](https://github.com/cloudflare/lua-resty-cookie) library for HTTP cookie manipulation. * [Routing requests to different MySQL queries based on URI arguments](http://openresty.org/#RoutingMySQLQueriesBasedOnURIArgs) * [Dynamic Routing Based on Redis and Lua](http://openresty.org/#DynamicRoutingBasedOnRedis) * [Using LuaRocks with ngx_lua](http://openresty.org/#UsingLuaRocks) * [Introduction to ngx_lua](https://github.com/openresty/lua-nginx-module/wiki/Introduction) * [ngx_devel_kit](https://github.com/simplresty/ngx_devel_kit) * [echo-nginx-module](http://github.com/openresty/echo-nginx-module) * [drizzle-nginx-module](http://github.com/openresty/drizzle-nginx-module) * [postgres-nginx-module](https://github.com/FRiCKLE/ngx_postgres) * [memc-nginx-module](http://github.com/openresty/memc-nginx-module) * [The OpenResty bundle](http://openresty.org) * [Nginx Systemtap Toolkit](https://github.com/openresty/nginx-systemtap-toolkit) [Back to TOC](#table-of-contents) Directives ========== * [lua_load_resty_core](#lua_load_resty_core) * [lua_capture_error_log](#lua_capture_error_log) * [lua_use_default_type](#lua_use_default_type) * [lua_malloc_trim](#lua_malloc_trim) * [lua_code_cache](#lua_code_cache) * [lua_regex_cache_max_entries](#lua_regex_cache_max_entries) * [lua_regex_match_limit](#lua_regex_match_limit) * [lua_package_path](#lua_package_path) * [lua_package_cpath](#lua_package_cpath) * [init_by_lua](#init_by_lua) * [init_by_lua_block](#init_by_lua_block) * [init_by_lua_file](#init_by_lua_file) * [init_worker_by_lua](#init_worker_by_lua) * [init_worker_by_lua_block](#init_worker_by_lua_block) * [init_worker_by_lua_file](#init_worker_by_lua_file) * [set_by_lua](#set_by_lua) * [set_by_lua_block](#set_by_lua_block) * [set_by_lua_file](#set_by_lua_file) * [content_by_lua](#content_by_lua) * [content_by_lua_block](#content_by_lua_block) * [content_by_lua_file](#content_by_lua_file) * [rewrite_by_lua](#rewrite_by_lua) * [rewrite_by_lua_block](#rewrite_by_lua_block) * [rewrite_by_lua_file](#rewrite_by_lua_file) * [access_by_lua](#access_by_lua) * [access_by_lua_block](#access_by_lua_block) * [access_by_lua_file](#access_by_lua_file) * [header_filter_by_lua](#header_filter_by_lua) * [header_filter_by_lua_block](#header_filter_by_lua_block) * [header_filter_by_lua_file](#header_filter_by_lua_file) * [body_filter_by_lua](#body_filter_by_lua) * [body_filter_by_lua_block](#body_filter_by_lua_block) * [body_filter_by_lua_file](#body_filter_by_lua_file) * [log_by_lua](#log_by_lua) * [log_by_lua_block](#log_by_lua_block) * [log_by_lua_file](#log_by_lua_file) * [balancer_by_lua_block](#balancer_by_lua_block) * [balancer_by_lua_file](#balancer_by_lua_file) * [lua_need_request_body](#lua_need_request_body) * [ssl_certificate_by_lua_block](#ssl_certificate_by_lua_block) * [ssl_certificate_by_lua_file](#ssl_certificate_by_lua_file) * [ssl_session_fetch_by_lua_block](#ssl_session_fetch_by_lua_block) * [ssl_session_fetch_by_lua_file](#ssl_session_fetch_by_lua_file) * [ssl_session_store_by_lua_block](#ssl_session_store_by_lua_block) * [ssl_session_store_by_lua_file](#ssl_session_store_by_lua_file) * [lua_shared_dict](#lua_shared_dict) * [lua_socket_connect_timeout](#lua_socket_connect_timeout) * [lua_socket_send_timeout](#lua_socket_send_timeout) * [lua_socket_send_lowat](#lua_socket_send_lowat) * [lua_socket_read_timeout](#lua_socket_read_timeout) * [lua_socket_buffer_size](#lua_socket_buffer_size) * [lua_socket_pool_size](#lua_socket_pool_size) * [lua_socket_keepalive_timeout](#lua_socket_keepalive_timeout) * [lua_socket_log_errors](#lua_socket_log_errors) * [lua_ssl_ciphers](#lua_ssl_ciphers) * [lua_ssl_crl](#lua_ssl_crl) * [lua_ssl_protocols](#lua_ssl_protocols) * [lua_ssl_trusted_certificate](#lua_ssl_trusted_certificate) * [lua_ssl_verify_depth](#lua_ssl_verify_depth) * [lua_http10_buffering](#lua_http10_buffering) * [rewrite_by_lua_no_postpone](#rewrite_by_lua_no_postpone) * [access_by_lua_no_postpone](#access_by_lua_no_postpone) * [lua_transform_underscores_in_response_headers](#lua_transform_underscores_in_response_headers) * [lua_check_client_abort](#lua_check_client_abort) * [lua_max_pending_timers](#lua_max_pending_timers) * [lua_max_running_timers](#lua_max_running_timers) * [lua_sa_restart](#lua_sa_restart) The basic building blocks of scripting Nginx with Lua are directives. Directives are used to specify when the user Lua code is run and how the result will be used. Below is a diagram showing the order in which directives are executed. ![Lua Nginx Modules Directives](https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png) [Back to TOC](#table-of-contents) lua_load_resty_core ------------------- **syntax:** *lua_load_resty_core on|off* **default:** *lua_load_resty_core on* **context:** *http* Controls whether the `resty.core` module (from [lua-resty-core](https://github.com/openresty/lua-resty-core)) should be loaded or not. When enabled, this directive is equivalent to executing the following when the Lua VM is created: ```lua require \u0026quot;resty.core\u0026quot;  Note that usage of the resty.core module is recommended, as its FFI implementation is both faster, safer, and more complete than the Lua C API of the ngx_lua module.\nIt must also be noted that the Lua C API of the ngx_lua module will eventually be removed, and usage of the FFI-based API (i.e. the resty.core module) will become mandatory. This directive only aims at providing a temporary backwards-compatibility mode in case of edge-cases.\nThis directive was first introduced in the v0.10.15 release.\nBack to TOC\nlua_capture_error_log syntax: lua_capture_error_log size\ndefault: none\ncontext: http\nEnables a buffer of the specified size for capturing all the nginx error log message data (not just those produced by this module or the nginx http subsystem, but everything) without touching files or disks.\nYou can use units like k and m in the size value, as in\nlua_capture_error_log 100k; As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!\nThis buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.\nThe size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).\nYou can read the messages in the buffer on the Lua land via the get_logs() function of the ngx.errlog module of the lua-resty-core library. This Lua API function will return the captured error log messages and also remove these already read from the global capturing buffer, making room for any new error log data. For this reason, the user should not configure this buffer to be too big if the user read the buffered error log data fast enough.\nNote that the log level specified in the standard error_log directive does have effect on this capturing facility. It only captures log messages of a level no lower than the specified log level in the error_log directive. The user can still choose to set an even higher filtering log level on the fly via the Lua API function errlog.set_filter_level. So it is more flexible than the static error_log directive.\nIt is worth noting that there is no way to capture the debugging logs without building OpenResty or NGINX with the ./configure option --with-debug. And enabling debugging logs is strongly discouraged in production builds due to high overhead.\nThis directive was first introduced in the v0.10.9 release.\nBack to TOC\nlua_use_default_type syntax: lua_use_default_type on | off\ndefault: lua_use_default_type on\ncontext: http, server, location, location if\nSpecifies whether to use the MIME type specified by the default_type directive for the default value of the Content-Type response header. Deactivate this directive if a default Content-Type response header for Lua request handlers is not desired.\nThis directive is turned on by default.\nThis directive was first introduced in the v0.9.1 release.\nBack to TOC\nlua_malloc_trim syntax: lua_malloc_trim \u0026lt;request-count\u0026gt;\ndefault: lua_malloc_trim 1000\ncontext: http\nAsks the underlying libc runtime library to release its cached free memory back to the operating system every N requests processed by the NGINX core. By default, N is 1000. You can configure the request count by using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and smaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint. Just tune the number for your own use cases.\nConfiguring the argument to 0 essentially turns off the periodical memory trimming altogether.\nlua_malloc_trim 0; # turn off trimming completely The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the log_subrequest on directives in nginx.conf may make the counting faster when subrequests are involved. By default, only \u0026ldquo;main requests\u0026rdquo; count.\nNote that this directive does not affect the memory allocated by LuaJIT\u0026rsquo;s own allocator based on the mmap system call.\nThis directive was first introduced in the v0.10.7 release.\nBack to TOC\nlua_code_cache syntax: lua_code_cache on | off\ndefault: lua_code_cache on\ncontext: http, server, location, location if\nEnables or disables the Lua code cache for Lua code in *_by_lua_file directives (like set_by_lua_file and content_by_lua_file) and Lua modules.\nWhen turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the 0.9.3 release. So the Lua files referenced in set_by_lua_file, content_by_lua_file, access_by_lua_file, and etc will not be cached and all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.\nPlease note however, that Lua code written inlined within nginx.conf such as those specified by set_by_lua, content_by_lua, access_by_lua, and rewrite_by_lua will not be updated when you edit the inlined Lua code in your nginx.conf file because only the Nginx config file parser can correctly parse the nginx.conf file and the only way is to reload the config file by sending a HUP signal or just to restart Nginx.\nEven when the code cache is enabled, Lua files which are loaded by dofile or loadfile in *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the init_by_lua or init_by_lua_file directives to load all such files or just make these Lua files true Lua modules and load them via require.\nThe ngx_lua module does not support the stat mode available with the Apache mod_lua module (yet).\nDisabling the Lua code cache is strongly discouraged for production use and should only be used during development as it has a significant negative impact on overall performance. For example, the performance of a \u0026ldquo;hello world\u0026rdquo; Lua example can drop by an order of magnitude after disabling the Lua code cache.\nBack to TOC\nlua_regex_cache_max_entries syntax: lua_regex_cache_max_entries \u0026lt;num\u0026gt;\ndefault: lua_regex_cache_max_entries 1024\ncontext: http\nSpecifies the maximum number of entries allowed in the worker process level compiled regex cache.\nThe regular expressions used in ngx.re.match, ngx.re.gmatch, ngx.re.sub, and ngx.re.gsub will be cached within this cache if the regex option o (i.e., compile-once flag) is specified.\nThe default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the o option was not specified) and there will be one, and only one, warning in the error.log file:\n2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...  If you are using the ngx.re.* implementation of lua-resty-core by loading the resty.core.regex module (or just the resty.core module), then an LRU cache is used for the regex cache being used here.\nDo not activate the o option for regular expressions (and/or replace string arguments for ngx.re.sub and ngx.re.gsub) that are generated on the fly and give rise to infinite variations to avoid hitting the specified limit.\nBack to TOC\nlua_regex_match_limit syntax: lua_regex_match_limit \u0026lt;num\u0026gt;\ndefault: lua_regex_match_limit 0\ncontext: http\nSpecifies the \u0026ldquo;match limit\u0026rdquo; used by the PCRE library when executing the ngx.re API. To quote the PCRE manpage, \u0026ldquo;the limit \u0026hellip; has the effect of limiting the amount of backtracking that can take place.\u0026rdquo;\nWhen the limit is hit, the error string \u0026ldquo;pcre_exec() failed: -8\u0026rdquo; will be returned by the ngx.re API functions on the Lua land.\nWhen setting the limit to 0, the default \u0026ldquo;match limit\u0026rdquo; when compiling the PCRE library is used. And this is the default value of this directive.\nThis directive was first introduced in the v0.8.5 release.\nBack to TOC\nlua_package_path syntax: lua_package_path \u0026lt;lua-style-path-str\u0026gt;\ndefault: The content of LUA_PATH environment variable or Lua\u0026rsquo;s compiled-in defaults.\ncontext: http\nSets the Lua module search path used by scripts specified by set_by_lua, content_by_lua and others. The path string is in standard Lua path form, and ;; can be used to stand for the original search paths.\nAs from the v0.5.0rc29 release, the special notation $prefix or ${prefix} can be used in the search path string to indicate the path of the server prefix usually determined by the -p PATH command-line option while starting the Nginx server.\nBack to TOC\nlua_package_cpath syntax: lua_package_cpath \u0026lt;lua-style-cpath-str\u0026gt;\ndefault: The content of LUA_CPATH environment variable or Lua\u0026rsquo;s compiled-in defaults.\ncontext: http\nSets the Lua C-module search path used by scripts specified by set_by_lua, content_by_lua and others. The cpath string is in standard Lua cpath form, and ;; can be used to stand for the original cpath.\nAs from the v0.5.0rc29 release, the special notation $prefix or ${prefix} can be used in the search path string to indicate the path of the server prefix usually determined by the -p PATH command-line option while starting the Nginx server.\nBack to TOC\ninit_by_lua syntax: init_by_lua \u0026lt;lua-script-str\u0026gt;\ncontext: http\nphase: loading-config\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the init_by_lua_block directive instead.\nRuns the Lua code specified by the argument \u0026lt;lua-script-str\u0026gt; on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.\nWhen Nginx receives the HUP signal and starts reloading the config file, the Lua VM will also be re-created and init_by_lua will run again on the new Lua VM. In case that the lua_code_cache directive is turned off (default on), the init_by_lua handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.\nUsually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems\u0026rsquo; copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:\n# this runs before forking out nginx worker processes:  init_by_lua_block { require \u0026#34;cjson\u0026#34; } server { location = /api { content_by_lua_block { -- the following require() will just return -- the alrady loaded module from package.loaded: ngx.say(require \u0026#34;cjson\u0026#34;.encode{dog = 5, cat = 6}) } } } You can also initialize the lua_shared_dict shm storage at this phase. Here is an example for this:\nlua_shared_dict dogs 1m; init_by_lua_block { local dogs = ngx.shared.dogs; dogs:set(\u0026#34;Tom\u0026#34;, 56) } server { location = /api { content_by_lua_block { local dogs = ngx.shared.dogs; ngx.say(dogs:get(\u0026#34;Tom\u0026#34;)) } } } But note that, the lua_shared_dict\u0026rsquo;s shm storage will not be cleared through a config reload (via the HUP signal, for example). So if you do not want to re-initialize the shm storage in your init_by_lua code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your init_by_lua code.\nBecause the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the Copy-on-write (COW) feature provided by many operating systems among all the worker processes, thus saving a lot of memory.\nDo not initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the Lua Variable Scope section for more details). The recommended way is to use proper Lua module files (but do not use the standard Lua function module() to define Lua modules because it pollutes the global namespace as well) and call require() to load your own module files in init_by_lua or other contexts (require() does cache the loaded Lua modules in the global package.loaded table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).\nOnly a small set of the Nginx API for Lua is supported in this context:\n Logging APIs: ngx.log and print, Shared Dictionary API: ngx.shared.DICT.  More Nginx APIs for Lua may be supported in this context upon future user requests.\nBasically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream\u0026rsquo;s host names) at the configure-loading phase.\nYou should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the root account.\nThis directive was first introduced in the v0.5.5 release.\nBack to TOC\ninit_by_lua_block syntax: init_by_lua_block { lua-script }\ncontext: http\nphase: loading-config\nSimilar to the init_by_lua directive except that this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping).\nFor instance,\ninit_by_lua_block { print(\u0026#34;I need no extra escaping here, for example: \\r\\nblah\u0026#34;) } This directive was first introduced in the v0.9.17 release.\nBack to TOC\ninit_by_lua_file syntax: init_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: http\nphase: loading-config\nEquivalent to init_by_lua, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code or Lua/LuaJIT bytecode to be executed.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nThis directive was first introduced in the v0.5.5 release.\nBack to TOC\ninit_worker_by_lua syntax: init_worker_by_lua \u0026lt;lua-script-str\u0026gt;\ncontext: http\nphase: starting-worker\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the init_worker_by_lua_block directive instead.\nRuns the specified Lua code upon every Nginx worker process\u0026rsquo;s startup when the master process is enabled. When the master process is disabled, this hook will just run after init_by_lua*.\nThis hook is often used to create per-worker reoccurring timers (via the ngx.timer.at Lua API), either for backend health-check or other timed routine work. Below is an example,\ninit_worker_by_lua \u0026#39; local delay = 3 -- in seconds local new_timer = ngx.timer.at local log = ngx.log local ERR = ngx.ERR local check check = function(premature) if not premature then -- do the health check or other routine work local ok, err = new_timer(delay, check) if not ok then log(ERR, \u0026#34;failed to create timer: \u0026#34;, err) return end end end local hdl, err = new_timer(delay, check) if not hdl then log(ERR, \u0026#34;failed to create timer: \u0026#34;, err) return end \u0026#39;; This directive was first introduced in the v0.9.5 release.\nThis hook no longer runs in the cache manager and cache loader processes since the v0.10.12 release.\nBack to TOC\ninit_worker_by_lua_block syntax: init_worker_by_lua_block { lua-script }\ncontext: http\nphase: starting-worker\nSimilar to the init_worker_by_lua directive except that this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping).\nFor instance,\ninit_worker_by_lua_block { print(\u0026#34;I need no extra escaping here, for example: \\r\\nblah\u0026#34;) } This directive was first introduced in the v0.9.17 release.\nThis hook no longer runs in the cache manager and cache loader processes since the v0.10.12 release.\nBack to TOC\ninit_worker_by_lua_file syntax: init_worker_by_lua_file \u0026lt;lua-file-path\u0026gt;\ncontext: http\nphase: starting-worker\nSimilar to init_worker_by_lua, but accepts the file path to a Lua source file or Lua bytecode file.\nThis directive was first introduced in the v0.9.5 release.\nThis hook no longer runs in the cache manager and cache loader processes since the v0.10.12 release.\nBack to TOC\nset_by_lua syntax: set_by_lua $res \u0026lt;lua-script-str\u0026gt; [$arg1 $arg2 \u0026hellip;]\ncontext: server, server if, location, location if\nphase: rewrite\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the set_by_lua_block directive instead.\nExecutes code specified in \u0026lt;lua-script-str\u0026gt; with optional input arguments $arg1 $arg2 ..., and returns string output to $res. The code in \u0026lt;lua-script-str\u0026gt; can make API calls and can retrieve input arguments from the ngx.arg table (index starts from 1 and increases sequentially).\nThis directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.\nThis directive is implemented by injecting custom commands into the standard ngx_http_rewrite_module\u0026rsquo;s command list. Because ngx_http_rewrite_module does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua \u0026ldquo;light thread\u0026rdquo; cannot work in this directive.\nAt least the following API functions are currently disabled within the context of set_by_lua:\n Output API functions (e.g., ngx.say and ngx.send_headers) Control API functions (e.g., ngx.exit) Subrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi) Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket). Sleeping API function ngx.sleep.  In addition, note that this directive can only write out a value to a single Nginx variable at a time. However, a workaround is possible using the ngx.var.VARIABLE interface.\nlocation /foo { set $diff \u0026#39;\u0026#39;; # we have to predefine the $diff variable here  set_by_lua $sum \u0026#39; local a = 32 local b = 56 ngx.var.diff = a - b; -- write to $diff directly return a + b; -- return the $sum value normally \u0026#39;; echo \u0026#34;sum = $sum, diff = $diff\u0026#34;; } This directive can be freely mixed with all directives of the ngx_http_rewrite_module, set-misc-nginx-module, and array-var-nginx-module modules. All of these directives will run in the same order as they appear in the config file.\nset $foo 32; set_by_lua $bar \u0026#39;return tonumber(ngx.var.foo) + 1\u0026#39;; set $baz \u0026#34;bar: $bar\u0026#34;; # $baz == \u0026#34;bar: 33\u0026#34; As from the v0.5.0rc29 release, Nginx variable interpolation is disabled in the \u0026lt;lua-script-str\u0026gt; argument of this directive and therefore, the dollar sign character ($) can be used directly.\nThis directive requires the ngx_devel_kit module.\nBack to TOC\nset_by_lua_block syntax: set_by_lua_block $res { lua-script }\ncontext: server, server if, location, location if\nphase: rewrite\nSimilar to the set_by_lua directive except that\n this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping), and this directive does not support extra arguments after the Lua script as in set_by_lua.  For example,\nset_by_lua_block $res { return 32 + math.cos(32) } # $res now has the value \u0026#34;32.834223360507\u0026#34; or alike. No special escaping is required in the Lua code block.\nThis directive was first introduced in the v0.9.17 release.\nBack to TOC\nset_by_lua_file syntax: set_by_lua_file $res \u0026lt;path-to-lua-script-file\u0026gt; [$arg1 $arg2 \u0026hellip;]\ncontext: server, server if, location, location if\nphase: rewrite\nEquivalent to set_by_lua, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or, as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nNginx variable interpolation is supported in the \u0026lt;path-to-lua-script-file\u0026gt; argument string of this directive. But special care must be taken for injection attacks.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nWhen the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching lua_code_cache off in nginx.conf to avoid reloading Nginx.\nThis directive requires the ngx_devel_kit module.\nBack to TOC\ncontent_by_lua syntax: content_by_lua \u0026lt;lua-script-str\u0026gt;\ncontext: location, location if\nphase: content\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the content_by_lua_block directive instead.\nActs as a \u0026ldquo;content handler\u0026rdquo; and executes Lua code string specified in \u0026lt;lua-script-str\u0026gt; for every request. The Lua code may make API calls and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).\nDo not use this directive and other content handler directives in the same location. For example, this directive and the proxy_pass directive should not be used in the same location.\nBack to TOC\ncontent_by_lua_block syntax: content_by_lua_block { lua-script }\ncontext: location, location if\nphase: content\nSimilar to the content_by_lua directive except that this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping).\nFor instance,\ncontent_by_lua_block { ngx.say(\u0026#34;I need no extra escaping here, for example: \\r\\nblah\u0026#34;) } This directive was first introduced in the v0.9.17 release.\nBack to TOC\ncontent_by_lua_file syntax: content_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: location, location if\nphase: content\nEquivalent to content_by_lua, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or, as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nNginx variables can be used in the \u0026lt;path-to-lua-script-file\u0026gt; string to provide flexibility. This however carries some risks and is not ordinarily recommended.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nWhen the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching lua_code_cache off in nginx.conf to avoid reloading Nginx.\nNginx variables are supported in the file path for dynamic dispatch, for example:\n# CAUTION: contents in nginx var must be carefully filtered,  # otherwise there\u0026#39;ll be great security risk!  location ~ ^/app/([-_a-zA-Z0-9/]+) { set $path $1; content_by_lua_file /path/to/lua/app/root/$path.lua; } But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.\nBack to TOC\nrewrite_by_lua syntax: rewrite_by_lua \u0026lt;lua-script-str\u0026gt;\ncontext: http, server, location, location if\nphase: rewrite tail\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the rewrite_by_lua_block directive instead.\nActs as a rewrite phase handler and executes Lua code string specified in \u0026lt;lua-script-str\u0026gt; for every request. The Lua code may make API calls and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).\nNote that this handler always runs after the standard ngx_http_rewrite_module. So the following will work as expected:\nlocation /foo { set $a 12; # create and initialize $a  set $b \u0026#34;\u0026#34;; # create and initialize $b  rewrite_by_lua \u0026#39;ngx.var.b = tonumber(ngx.var.a) + 1\u0026#39;; echo \u0026#34;res = $b\u0026#34;; } because set $a 12 and set $b \u0026quot;\u0026quot; run before rewrite_by_lua.\nOn the other hand, the following will not work as expected:\n? location /foo { ? set $a 12; # create and initialize $a  ? set $b \u0026#39;\u0026#39;; # create and initialize $b  ? rewrite_by_lua \u0026#39;ngx.var.b = tonumber(ngx.var.a) + 1\u0026#39;; ? if ($b = \u0026#39;13\u0026#39;) { ? rewrite ^ /bar redirect; ? break; ? } ? ? echo \u0026#34;res = $b\u0026#34;; ? } because if runs before rewrite_by_lua even if it is placed after rewrite_by_lua in the config.\nThe right way of doing this is as follows:\nlocation /foo { set $a 12; # create and initialize $a  set $b \u0026#39;\u0026#39;; # create and initialize $b  rewrite_by_lua \u0026#39; ngx.var.b = tonumber(ngx.var.a) + 1 if tonumber(ngx.var.b) == 13 then return ngx.redirect(\u0026#34;/bar\u0026#34;); end \u0026#39;; echo \u0026#34;res = $b\u0026#34;; } Note that the ngx_eval module can be approximated by using rewrite_by_lua. For example,\nlocation / { eval $res { proxy_pass http://foo.com/check-spam; } if ($res = \u0026#39;spam\u0026#39;) { rewrite ^ /terms-of-use.html redirect; } fastcgi_pass ...; } can be implemented in ngx_lua as:\nlocation = /check-spam { internal; proxy_pass http://foo.com/check-spam; } location / { rewrite_by_lua \u0026#39; local res = ngx.location.capture(\u0026#34;/check-spam\u0026#34;) if res.body == \u0026#34;spam\u0026#34; then return ngx.redirect(\u0026#34;/terms-of-use.html\u0026#34;) end \u0026#39;; fastcgi_pass ...; } Just as any other rewrite phase handlers, rewrite_by_lua also runs in subrequests.\nNote that when calling ngx.exit(ngx.OK) within a rewrite_by_lua handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a rewrite_by_lua handler, calling ngx.exit with status \u0026gt;= 200 (ngx.HTTP_OK) and status \u0026lt; 300 (ngx.HTTP_SPECIAL_RESPONSE) for successful quits and ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) (or its friends) for failures.\nIf the ngx_http_rewrite_module\u0026rsquo;s rewrite directive is used to change the URI and initiate location re-lookups (internal redirections), then any rewrite_by_lua or rewrite_by_lua_file code sequences within the current location will not be executed. For example,\nlocation /foo { rewrite ^ /bar; rewrite_by_lua \u0026#39;ngx.exit(503)\u0026#39;; } location /bar { ... } Here the Lua code ngx.exit(503) will never run. This will be the case if rewrite ^ /bar last is used as this will similarly initiate an internal redirection. If the break modifier is used instead, there will be no internal redirection and the rewrite_by_lua code will be executed.\nThe rewrite_by_lua code will always run at the end of the rewrite request-processing phase unless rewrite_by_lua_no_postpone is turned on.\nBack to TOC\nrewrite_by_lua_block syntax: rewrite_by_lua_block { lua-script }\ncontext: http, server, location, location if\nphase: rewrite tail\nSimilar to the rewrite_by_lua directive except that this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping).\nFor instance,\nrewrite_by_lua_block { do_something(\u0026#34;hello, world!\\nhiya\\n\u0026#34;) } This directive was first introduced in the v0.9.17 release.\nBack to TOC\nrewrite_by_lua_file syntax: rewrite_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: http, server, location, location if\nphase: rewrite tail\nEquivalent to rewrite_by_lua, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or, as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nNginx variables can be used in the \u0026lt;path-to-lua-script-file\u0026gt; string to provide flexibility. This however carries some risks and is not ordinarily recommended.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nWhen the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching lua_code_cache off in nginx.conf to avoid reloading Nginx.\nThe rewrite_by_lua_file code will always run at the end of the rewrite request-processing phase unless rewrite_by_lua_no_postpone is turned on.\nNginx variables are supported in the file path for dynamic dispatch just as in content_by_lua_file.\nBack to TOC\naccess_by_lua syntax: access_by_lua \u0026lt;lua-script-str\u0026gt;\ncontext: http, server, location, location if\nphase: access tail\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the access_by_lua_block directive instead.\nActs as an access phase handler and executes Lua code string specified in \u0026lt;lua-script-str\u0026gt; for every request. The Lua code may make API calls and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).\nNote that this handler always runs after the standard ngx_http_access_module. So the following will work as expected:\nlocation / { deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; deny all; access_by_lua \u0026#39; local res = ngx.location.capture(\u0026#34;/mysql\u0026#34;, { ... }) ... \u0026#39;; # proxy_pass/fastcgi_pass/...  } That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by access_by_lua.\nNote that the ngx_auth_request module can be approximated by using access_by_lua:\nlocation / { auth_request /auth; # proxy_pass/fastcgi_pass/postgres_pass/...  } can be implemented in ngx_lua as:\nlocation / { access_by_lua \u0026#39; local res = ngx.location.capture(\u0026#34;/auth\u0026#34;) if res.status == ngx.HTTP_OK then return end if res.status == ngx.HTTP_FORBIDDEN then ngx.exit(res.status) end ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) \u0026#39;; # proxy_pass/fastcgi_pass/postgres_pass/...  } As with other access phase handlers, access_by_lua will not run in subrequests.\nNote that when calling ngx.exit(ngx.OK) within a access_by_lua handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a access_by_lua handler, calling ngx.exit with status \u0026gt;= 200 (ngx.HTTP_OK) and status \u0026lt; 300 (ngx.HTTP_SPECIAL_RESPONSE) for successful quits and ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) (or its friends) for failures.\nStarting from the v0.9.20 release, you can use the access_by_lua_no_postpone directive to control when to run this handler inside the \u0026ldquo;access\u0026rdquo; request-processing phase of NGINX.\nBack to TOC\naccess_by_lua_block syntax: access_by_lua_block { lua-script }\ncontext: http, server, location, location if\nphase: access tail\nSimilar to the access_by_lua directive except that this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping).\nFor instance,\naccess_by_lua_block { do_something(\u0026#34;hello, world!\\nhiya\\n\u0026#34;) } This directive was first introduced in the v0.9.17 release.\nBack to TOC\naccess_by_lua_file syntax: access_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: http, server, location, location if\nphase: access tail\nEquivalent to access_by_lua, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or, as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nNginx variables can be used in the \u0026lt;path-to-lua-script-file\u0026gt; string to provide flexibility. This however carries some risks and is not ordinarily recommended.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nWhen the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching lua_code_cache off in nginx.conf to avoid repeatedly reloading Nginx.\nNginx variables are supported in the file path for dynamic dispatch just as in content_by_lua_file.\nBack to TOC\nheader_filter_by_lua syntax: header_filter_by_lua \u0026lt;lua-script-str\u0026gt;\ncontext: http, server, location, location if\nphase: output-header-filter\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the header_filter_by_lua_block directive instead.\nUses Lua code specified in \u0026lt;lua-script-str\u0026gt; to define an output header filter.\nNote that the following API functions are currently disabled within this context:\n Output API functions (e.g., ngx.say and ngx.send_headers) Control API functions (e.g., ngx.redirect and ngx.exec) Subrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi) Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).  Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:\nlocation / { proxy_pass http://mybackend; header_filter_by_lua \u0026#39;ngx.header.Foo = \u0026#34;blah\u0026#34;\u0026#39;; } This directive was first introduced in the v0.2.1rc20 release.\nBack to TOC\nheader_filter_by_lua_block syntax: header_filter_by_lua_block { lua-script }\ncontext: http, server, location, location if\nphase: output-header-filter\nSimilar to the header_filter_by_lua directive except that this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping).\nFor instance,\nheader_filter_by_lua_block { ngx.header[\u0026#34;content-length\u0026#34;] = nil } This directive was first introduced in the v0.9.17 release.\nBack to TOC\nheader_filter_by_lua_file syntax: header_filter_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: http, server, location, location if\nphase: output-header-filter\nEquivalent to header_filter_by_lua, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nThis directive was first introduced in the v0.2.1rc20 release.\nBack to TOC\nbody_filter_by_lua syntax: body_filter_by_lua \u0026lt;lua-script-str\u0026gt;\ncontext: http, server, location, location if\nphase: output-body-filter\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the body_filter_by_lua_block directive instead.\nUses Lua code specified in \u0026lt;lua-script-str\u0026gt; to define an output body filter.\nThe input data chunk is passed via ngx.arg[1] (as a Lua string value) and the \u0026ldquo;eof\u0026rdquo; flag indicating the end of the response body data stream is passed via ngx.arg[2] (as a Lua boolean value).\nBehind the scene, the \u0026ldquo;eof\u0026rdquo; flag is just the last_buf (for main requests) or last_in_chain (for subrequests) flag of the Nginx chain link buffers. (Before the v0.7.14 release, the \u0026ldquo;eof\u0026rdquo; flag does not work at all in subrequests.)\nThe output data stream can be aborted immediately by running the following Lua statement:\nreturn ngx.ERROR This will truncate the response body and usually result in incomplete and also invalid responses.\nThe Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding ngx.arg[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:\nlocation / { proxy_pass http://mybackend; body_filter_by_lua \u0026#39;ngx.arg[1] = string.upper(ngx.arg[1])\u0026#39;; } When setting nil or an empty Lua string value to ngx.arg[1], no data chunk will be passed to the downstream Nginx output filters at all.\nLikewise, new \u0026ldquo;eof\u0026rdquo; flag can also be specified by setting a boolean value to ngx.arg[2]. For example,\nlocation /t { echo hello world; echo hiya globe; body_filter_by_lua \u0026#39; local chunk = ngx.arg[1] if string.match(chunk, \u0026#34;hello\u0026#34;) then ngx.arg[2] = true -- new eof return end -- just throw away any remaining chunk data ngx.arg[1] = nil \u0026#39;; } Then GET /t will just return the output\nhello world  That is, when the body filter sees a chunk containing the word \u0026ldquo;hello\u0026rdquo;, then it will set the \u0026ldquo;eof\u0026rdquo; flag to true immediately, resulting in truncated but still valid responses.\nWhen the Lua code may change the length of the response body, then it is required to always clear out the Content-Length response header (if any) in a header filter to enforce streaming output, as in\nlocation /foo { # fastcgi_pass/proxy_pass/...  header_filter_by_lua_block { ngx.header.content_length = nil } body_filter_by_lua \u0026#39;ngx.arg[1] = string.len(ngx.arg[1]) .. \u0026#34;\\\\n\u0026#34;\u0026#39;; } Note that the following API functions are currently disabled within this context due to the limitations in NGINX output filter\u0026rsquo;s current implementation:\n Output API functions (e.g., ngx.say and ngx.send_headers) Control API functions (e.g., ngx.exit and ngx.exec) Subrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi) Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).  Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.\nThis directive was first introduced in the v0.5.0rc32 release.\nBack to TOC\nbody_filter_by_lua_block syntax: body_filter_by_lua_block { lua-script-str }\ncontext: http, server, location, location if\nphase: output-body-filter\nSimilar to the body_filter_by_lua directive except that this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping).\nFor instance,\nbody_filter_by_lua_block { local data, eof = ngx.arg[1], ngx.arg[2] } This directive was first introduced in the v0.9.17 release.\nBack to TOC\nbody_filter_by_lua_file syntax: body_filter_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: http, server, location, location if\nphase: output-body-filter\nEquivalent to body_filter_by_lua, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or, as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nThis directive was first introduced in the v0.5.0rc32 release.\nBack to TOC\nlog_by_lua syntax: log_by_lua \u0026lt;lua-script-str\u0026gt;\ncontext: http, server, location, location if\nphase: log\nNOTE Use of this directive is discouraged following the v0.9.17 release. Use the log_by_lua_block directive instead.\nRuns the Lua source code inlined as the \u0026lt;lua-script-str\u0026gt; at the log request processing phase. This does not replace the current access logs, but runs before.\nNote that the following API functions are currently disabled within this context:\n Output API functions (e.g., ngx.say and ngx.send_headers) Control API functions (e.g., ngx.exit) Subrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi) Cosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).  Here is an example of gathering average data for $upstream_response_time:\nlua_shared_dict log_dict 5M; server { location / { proxy_pass http://mybackend; log_by_lua \u0026#39; local log_dict = ngx.shared.log_dict local upstream_time = tonumber(ngx.var.upstream_response_time) local sum = log_dict:get(\u0026#34;upstream_time-sum\u0026#34;) or 0 sum = sum + upstream_time log_dict:set(\u0026#34;upstream_time-sum\u0026#34;, sum) local newval, err = log_dict:incr(\u0026#34;upstream_time-nb\u0026#34;, 1) if not newval and err == \u0026#34;not found\u0026#34; then log_dict:add(\u0026#34;upstream_time-nb\u0026#34;, 0) log_dict:incr(\u0026#34;upstream_time-nb\u0026#34;, 1) end \u0026#39;; } location = /status { content_by_lua_block { local log_dict = ngx.shared.log_dict local sum = log_dict:get(\u0026#34;upstream_time-sum\u0026#34;) local nb = log_dict:get(\u0026#34;upstream_time-nb\u0026#34;) if nb and sum then ngx.say(\u0026#34;average upstream response time: \u0026#34;, sum / nb, \u0026#34; (\u0026#34;, nb, \u0026#34; reqs)\u0026#34;) else ngx.say(\u0026#34;no data yet\u0026#34;) end } } } This directive was first introduced in the v0.5.0rc31 release.\nBack to TOC\nlog_by_lua_block syntax: log_by_lua_block { lua-script }\ncontext: http, server, location, location if\nphase: log\nSimilar to the log_by_lua directive except that this directive inlines the Lua source directly inside a pair of curly braces ({}) instead of in an NGINX string literal (which requires special character escaping).\nFor instance,\nlog_by_lua_block { print(\u0026#34;I need no extra escaping here, for example: \\r\\nblah\u0026#34;) } This directive was first introduced in the v0.9.17 release.\nBack to TOC\nlog_by_lua_file syntax: log_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: http, server, location, location if\nphase: log\nEquivalent to log_by_lua, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or, as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nThis directive was first introduced in the v0.5.0rc31 release.\nBack to TOC\nbalancer_by_lua_block syntax: balancer_by_lua_block { lua-script }\ncontext: upstream\nphase: content\nThis directive runs Lua code as an upstream balancer for any upstream entities defined by the upstream {} configuration block.\nFor instance,\nupstream foo { server 127.0.0.1; balancer_by_lua_block { -- use Lua to do something interesting here -- as a dynamic balancer } } server { location / { proxy_pass http://foo; } } The resulting Lua load balancer can work with any existing nginx upstream modules like ngx_proxy and ngx_fastcgi.\nAlso, the Lua load balancer can work with the standard upstream connection pool mechanism, i.e., the standard keepalive directive. Just ensure that the keepalive directive is used after this balancer_by_lua_block directive in a single upstream {} configuration block.\nThe Lua load balancer can totally ignore the list of servers defined in the upstream {} block and select peer from a completely dynamic server list (even changing per request) via the ngx.balancer module from the lua-resty-core library.\nThe Lua code handler registered by this directive might get called more than once in a single downstream request when the nginx upstream mechanism retries the request on conditions specified by directives like the proxy_next_upstream directive.\nThis Lua code execution context does not support yielding, so Lua APIs that may yield (like cosockets and \u0026ldquo;light threads\u0026rdquo;) are disabled in this context. One can usually work around this limitation by doing such operations in an earlier phase handler (like access_by_lua*) and passing along the result into this context via the ngx.ctx table.\nThis directive was first introduced in the v0.10.0 release.\nBack to TOC\nbalancer_by_lua_file syntax: balancer_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: upstream\nphase: content\nEquivalent to balancer_by_lua_block, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or, as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nThis directive was first introduced in the v0.10.0 release.\nBack to TOC\nlua_need_request_body syntax: lua_need_request_body \u0026lt;on|off\u0026gt;\ndefault: off\ncontext: http, server, location, location if\nphase: depends on usage\nDetermines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned on or the ngx.req.read_body function should be called within the Lua code.\nTo read the request body data within the $request_body variable, client_body_buffer_size must have the same value as client_max_body_size. Because when the content length exceeds client_body_buffer_size but less than client_max_body_size, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the $request_body variable.\nIf the current location includes rewrite_by_lua* directives, then the request body will be read just before the rewrite_by_lua* code is run (and also at the rewrite phase). Similarly, if only content_by_lua is specified, the request body will not be read until the content handler\u0026rsquo;s Lua code is about to run (i.e., the request body will be read during the content phase).\nIt is recommended however, to use the ngx.req.read_body and ngx.req.discard_body functions for finer control over the request body reading process instead.\nThis also applies to access_by_lua*.\nBack to TOC\nssl_certificate_by_lua_block syntax: ssl_certificate_by_lua_block { lua-script }\ncontext: server\nphase: right-before-SSL-handshake\nThis directive runs user Lua code when NGINX is about to start the SSL handshake for the downstream SSL (https) connections.\nIt is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request basis. It is also useful to load such handshake configurations nonblockingly from the remote (for example, with the cosocket API). And one can also do per-request OCSP stapling handling in pure Lua here as well.\nAnother typical use case is to do SSL handshake traffic control nonblockingly in this context, with the help of the lua-resty-limit-traffic#readme library, for example.\nOne can also do interesting things with the SSL handshake requests from the client side, like rejecting old SSL clients using the SSLv3 protocol or even below selectively.\nThe ngx.ssl and ngx.ocsp Lua modules provided by the lua-resty-core library are particularly useful in this context. You can use the Lua API offered by these two Lua modules to manipulate the SSL certificate chain and private key for the current SSL connection being initiated.\nThis Lua handler does not run at all, however, when NGINX/OpenSSL successfully resumes the SSL session via SSL session IDs or TLS session tickets for the current SSL connection. In other words, this Lua handler only runs when NGINX has to initiate a full SSL handshake.\nBelow is a trivial example using the ngx.ssl module at the same time:\nserver { listen 443 ssl; server_name test.com; ssl_certificate_by_lua_block { print(\u0026#34;About to initiate a new SSL handshake!\u0026#34;) } location / { root html; } } See more complicated examples in the ngx.ssl and ngx.ocsp Lua modules\u0026rsquo; official documentation.\nUncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the ngx.exit call with an error code like ngx.ERROR.\nThis Lua code execution context does support yielding, so Lua APIs that may yield (like cosockets, sleeping, and \u0026ldquo;light threads\u0026rdquo;) are enabled in this context.\nNote, however, you still need to configure the ssl_certificate and ssl_certificate_key directives even though you will not use this static certificate and private key at all. This is because the NGINX core requires their appearance otherwise you are seeing the following error while starting NGINX:\nnginx: [emerg] no ssl configured for the server  This directive currently requires the following NGINX core patch to work correctly:\nhttp://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html\nThe bundled version of the NGINX core in OpenResty 1.9.7.2 (or above) already has this patch applied.\nFurthermore, one needs at least OpenSSL 1.0.2e for this directive to work.\nThis directive was first introduced in the v0.10.0 release.\nBack to TOC\nssl_certificate_by_lua_file syntax: ssl_certificate_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: server\nphase: right-before-SSL-handshake\nEquivalent to ssl_certificate_by_lua_block, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or, as from the v0.5.0rc32 release, the Lua/LuaJIT bytecode to be executed.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nThis directive was first introduced in the v0.10.0 release.\nBack to TOC\nssl_session_fetch_by_lua_block syntax: ssl_session_fetch_by_lua_block { lua-script }\ncontext: http\nphase: right-before-SSL-handshake\nThis directive runs Lua code to look up and load the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream.\nThe Lua API for obtaining the current session ID and loading a cached SSL session data is provided in the ngx.ssl.session Lua module shipped with the lua-resty-core library.\nLua APIs that may yield, like ngx.sleep and cosockets, are enabled in this context.\nThis hook, together with the ssl_session_store_by_lua* hook, can be used to implement distributed caching mechanisms in pure Lua (based on the cosocket API, for example). If a cached SSL session is found and loaded into the current SSL connection context, SSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.\nPlease note that TLS session tickets are very different and it is the clients\u0026rsquo; responsibility to cache the SSL session state when session tickets are used. SSL session resumptions based on TLS session tickets would happen automatically without going through this hook (nor the ssl_session_store_by_lua* hook). This hook is mainly for older or less capable SSL clients that can only do SSL sessions by session IDs.\nWhen ssl_certificate_by_lua* is specified at the same time, this hook usually runs before ssl_certificate_by_lua*. When the SSL session is found and successfully loaded for the current SSL connection, SSL session resumption will happen and thus bypass the ssl_certificate_by_lua* hook completely. In this case, NGINX also bypasses the ssl_session_store_by_lua* hook, for obvious reasons.\nTo easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:\nssl_session_tickets off;  But do not forget to comment this line out before publishing your site to the world.\nIf you are using the official pre-built packages for OpenResty 1.11.2.1 or later, then everything should work out of the box.\nIf you are not using one of the OpenSSL packages provided by OpenResty, you will need to apply patches to OpenSSL in order to use this hook:\nhttps://openresty.org/en/openssl-patches.html\nSimilarly, if you are not using the NGINX core shipped with OpenResty 1.11.2.1 or later, you will need to apply patches to the standard NGINX core:\nhttps://openresty.org/en/nginx-ssl-patches.html\nThis directive was first introduced in the v0.10.6 release.\nNote that: this directive is only allowed to used in http context from the v0.10.7 release (because SSL session resumption happens before server name dispatch).\nBack to TOC\nssl_session_fetch_by_lua_file syntax: ssl_session_fetch_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: http\nphase: right-before-SSL-handshake\nEquivalent to ssl_session_fetch_by_lua_block, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or rather, the Lua/LuaJIT bytecode to be executed.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nThis directive was first introduced in the v0.10.6 release.\nNote that: this directive is only allowed to used in http context from the v0.10.7 release (because SSL session resumption happens before server name dispatch).\nBack to TOC\nssl_session_store_by_lua_block syntax: ssl_session_store_by_lua_block { lua-script }\ncontext: http\nphase: right-after-SSL-handshake\nThis directive runs Lua code to fetch and save the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream. The saved or cached SSL session data can be used for future SSL connections to resume SSL sessions without going through the full SSL handshake process (which is very expensive in terms of CPU time).\nLua APIs that may yield, like ngx.sleep and cosockets, are disabled in this context. You can still, however, use the ngx.timer.at API to create 0-delay timers to save the SSL session data asynchronously to external services (like redis or memcached).\nThe Lua API for obtaining the current session ID and the associated session state data is provided in the ngx.ssl.session Lua module shipped with the lua-resty-core library.\nTo easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:\nssl_session_tickets off;  But do not forget to comment this line out before publishing your site to the world.\nThis directive was first introduced in the v0.10.6 release.\nNote that: this directive is only allowed to used in http context from the v0.10.7 release (because SSL session resumption happens before server name dispatch).\nBack to TOC\nssl_session_store_by_lua_file syntax: ssl_session_store_by_lua_file \u0026lt;path-to-lua-script-file\u0026gt;\ncontext: http\nphase: right-after-SSL-handshake\nEquivalent to ssl_session_store_by_lua_block, except that the file specified by \u0026lt;path-to-lua-script-file\u0026gt; contains the Lua code, or rather, the Lua/LuaJIT bytecode to be executed.\nWhen a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.\nThis directive was first introduced in the v0.10.6 release.\nNote that: this directive is only allowed to used in http context from the v0.10.7 release (because SSL session resumption happens before server name dispatch).\nBack to TOC\nlua_shared_dict syntax: lua_shared_dict \u0026lt;name\u0026gt; \u0026lt;size\u0026gt;\ndefault: no\ncontext: http\nphase: depends on usage\nDeclares a shared memory zone, \u0026lt;name\u0026gt;, to serve as storage for the shm based Lua dictionary ngx.shared.\u0026lt;name\u0026gt;.\nShared memory zones are always shared by all the nginx worker processes in the current nginx server instance.\nThe \u0026lt;size\u0026gt; argument accepts size units such as k and m:\nhttp { lua_shared_dict dogs 10m; ... } The hard-coded minimum size is 8KB while the practical minimum size depends on actual user data set (some people start with 12KB).\nSee ngx.shared.DICT for details.\nThis directive was first introduced in the v0.3.1rc22 release.\nBack to TOC\nlua_socket_connect_timeout syntax: lua_socket_connect_timeout \u0026lt;time\u0026gt;\ndefault: lua_socket_connect_timeout 60s\ncontext: http, server, location\nThis directive controls the default timeout value used in TCP/unix-domain socket object\u0026rsquo;s connect method and can be overridden by the settimeout or settimeouts methods.\nThe \u0026lt;time\u0026gt; argument can be an integer, with an optional time unit, like s (second), ms (millisecond), m (minute). The default time unit is s, i.e., \u0026ldquo;second\u0026rdquo;. The default setting is 60s.\nThis directive was first introduced in the v0.5.0rc1 release.\nBack to TOC\nlua_socket_send_timeout syntax: lua_socket_send_timeout \u0026lt;time\u0026gt;\ndefault: lua_socket_send_timeout 60s\ncontext: http, server, location\nControls the default timeout value used in TCP/unix-domain socket object\u0026rsquo;s send method and can be overridden by the settimeout or settimeouts methods.\nThe \u0026lt;time\u0026gt; argument can be an integer, with an optional time unit, like s (second), ms (millisecond), m (minute). The default time unit is s, i.e., \u0026ldquo;second\u0026rdquo;. The default setting is 60s.\nThis directive was first introduced in the v0.5.0rc1 release.\nBack to TOC\nlua_socket_send_lowat syntax: lua_socket_send_lowat \u0026lt;size\u0026gt;\ndefault: lua_socket_send_lowat 0\ncontext: http, server, location\nControls the lowat (low water) value for the cosocket send buffer.\nBack to TOC\nlua_socket_read_timeout syntax: lua_socket_read_timeout \u0026lt;time\u0026gt;\ndefault: lua_socket_read_timeout 60s\ncontext: http, server, location\nphase: depends on usage\nThis directive controls the default timeout value used in TCP/unix-domain socket object\u0026rsquo;s receive method and iterator functions returned by the receiveuntil method. This setting can be overridden by the settimeout or settimeouts methods.\nThe \u0026lt;time\u0026gt; argument can be an integer, with an optional time unit, like s (second), ms (millisecond), m (minute). The default time unit is s, i.e., \u0026ldquo;second\u0026rdquo;. The default setting is 60s.\nThis directive was first introduced in the v0.5.0rc1 release.\nBack to TOC\nlua_socket_buffer_size syntax: lua_socket_buffer_size \u0026lt;size\u0026gt;\ndefault: lua_socket_buffer_size 4k/8k\ncontext: http, server, location\nSpecifies the buffer size used by cosocket reading operations.\nThis buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even 1 byte buffer size should still work everywhere but the performance could be terrible.\nThis directive was first introduced in the v0.5.0rc1 release.\nBack to TOC\nlua_socket_pool_size syntax: lua_socket_pool_size \u0026lt;size\u0026gt;\ndefault: lua_socket_pool_size 30\ncontext: http, server, location\nSpecifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).\nDefault to 30 connections for every pool.\nWhen the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.\nNote that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.\nThis directive was first introduced in the v0.5.0rc1 release.\nBack to TOC\nlua_socket_keepalive_timeout syntax: lua_socket_keepalive_timeout \u0026lt;time\u0026gt;\ndefault: lua_socket_keepalive_timeout 60s\ncontext: http, server, location\nThis directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects\u0026rsquo; setkeepalive method.\nThe \u0026lt;time\u0026gt; argument can be an integer, with an optional time unit, like s (second), ms (millisecond), m (minute). The default time unit is s, i.e., \u0026ldquo;second\u0026rdquo;. The default setting is 60s.\nThis directive was first introduced in the v0.5.0rc1 release.\nBack to TOC\nlua_socket_log_errors syntax: lua_socket_log_errors on|off\ndefault: lua_socket_log_errors on\ncontext: http, server, location\nThis directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).\nThis directive was first introduced in the v0.5.13 release.\nBack to TOC\nlua_ssl_ciphers syntax: lua_ssl_ciphers \u0026lt;ciphers\u0026gt;\ndefault: lua_ssl_ciphers DEFAULT\ncontext: http, server, location\nSpecifies the enabled ciphers for requests to a SSL/TLS server in the tcpsock:sslhandshake method. The ciphers are specified in the format understood by the OpenSSL library.\nThe full list can be viewed using the “openssl ciphers” command.\nThis directive was first introduced in the v0.9.11 release.\nBack to TOC\nlua_ssl_crl syntax: lua_ssl_crl \u0026lt;file\u0026gt;\ndefault: no\ncontext: http, server, location\nSpecifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the tcpsock:sslhandshake method.\nThis directive was first introduced in the v0.9.11 release.\nBack to TOC\nlua_ssl_protocols syntax: lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]\ndefault: lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2\ncontext: http, server, location\nEnables the specified protocols for requests to a SSL/TLS server in the tcpsock:sslhandshake method.\nThe support for the TLSv1.3 parameter requires version v0.10.12 and OpenSSL 1.1.1.\nThis directive was first introduced in the v0.9.11 release.\nBack to TOC\nlua_ssl_trusted_certificate syntax: lua_ssl_trusted_certificate \u0026lt;file\u0026gt;\ndefault: no\ncontext: http, server, location\nSpecifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the tcpsock:sslhandshake method.\nThis directive was first introduced in the v0.9.11 release.\nSee also lua_ssl_verify_depth.\nBack to TOC\nlua_ssl_verify_depth syntax: lua_ssl_verify_depth \u0026lt;number\u0026gt;\ndefault: lua_ssl_verify_depth 1\ncontext: http, server, location\nSets the verification depth in the server certificates chain.\nThis directive was first introduced in the v0.9.11 release.\nSee also lua_ssl_trusted_certificate.\nBack to TOC\nlua_http10_buffering syntax: lua_http10_buffering on|off\ndefault: lua_http10_buffering on\ncontext: http, server, location, location-if\nEnables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper Content-Length response header.\nIf the Lua code explicitly sets a Content-Length response header before sending the headers (either explicitly via ngx.send_headers or implicitly via the first ngx.say or ngx.print call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.\nTo output very large response data in a streaming fashion (via the ngx.flush call, for example), this directive MUST be turned off to minimize memory usage.\nThis directive is turned on by default.\nThis directive was first introduced in the v0.5.0rc19 release.\nBack to TOC\nrewrite_by_lua_no_postpone syntax: rewrite_by_lua_no_postpone on|off\ndefault: rewrite_by_lua_no_postpone off\ncontext: http\nControls whether or not to disable postponing rewrite_by_lua* directives to run at the end of the rewrite request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the rewrite phase.\nThis directive was first introduced in the v0.5.0rc29 release.\nBack to TOC\naccess_by_lua_no_postpone syntax: access_by_lua_no_postpone on|off\ndefault: access_by_lua_no_postpone off\ncontext: http\nControls whether or not to disable postponing access_by_lua* directives to run at the end of the access request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the access phase.\nThis directive was first introduced in the v0.9.20 release.\nBack to TOC\nlua_transform_underscores_in_response_headers syntax: lua_transform_underscores_in_response_headers on|off\ndefault: lua_transform_underscores_in_response_headers on\ncontext: http, server, location, location-if\nControls whether to transform underscores (_) in the response header names specified in the ngx.header.HEADER API to hypens (-).\nThis directive was first introduced in the v0.5.0rc32 release.\nBack to TOC\nlua_check_client_abort syntax: lua_check_client_abort on|off\ndefault: lua_check_client_abort off\ncontext: http, server, location, location-if\nThis directive controls whether to check for premature client connection abortion.\nWhen this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by ngx.on_abort) or just stop and clean up all the Lua \u0026ldquo;light threads\u0026rdquo; running in the current request\u0026rsquo;s request handler when there is no user callback function registered.\nAccording to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via ngx.req.socket, then ngx_lua will neither stop all the running \u0026ldquo;light threads\u0026rdquo; nor call the user callback (if ngx.on_abort has been called). Instead, the reading operation on ngx.req.socket will just return the error message \u0026ldquo;client aborted\u0026rdquo; as the second return value (the first return value is surely nil).\nWhen TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a FIN packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the TCP keepalive support in your system\u0026rsquo;s TCP stack implementation in order to detect \u0026ldquo;half-open\u0026rdquo; TCP connections in time.\nFor example, on Linux, you can configure the standard listen directive in your nginx.conf file like this:\nlisten 80 so_keepalive=2s:2s:8; On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:\n# sysctl net.inet.tcp.keepintvl=2000 # sysctl net.inet.tcp.keepidle=2000  This directive was first introduced in the v0.7.4 release.\nSee also ngx.on_abort.\nBack to TOC\nlua_max_pending_timers syntax: lua_max_pending_timers \u0026lt;count\u0026gt;\ndefault: lua_max_pending_timers 1024\ncontext: http\nControls the maximum number of pending timers allowed.\nPending timers are those timers that have not expired yet.\nWhen exceeding this limit, the ngx.timer.at call will immediately return nil and the error string \u0026ldquo;too many pending timers\u0026rdquo;.\nThis directive was first introduced in the v0.8.0 release.\nBack to TOC\nlua_max_running_timers syntax: lua_max_running_timers \u0026lt;count\u0026gt;\ndefault: lua_max_running_timers 256\ncontext: http\nControls the maximum number of \u0026ldquo;running timers\u0026rdquo; allowed.\nRunning timers are those timers whose user callback functions are still running.\nWhen exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message \u0026ldquo;N lua_max_running_timers are not enough\u0026rdquo; where \u0026ldquo;N\u0026rdquo; is the current value of this directive.\nThis directive was first introduced in the v0.8.0 release.\nBack to TOC\nlua_sa_restart syntax: lua_sa_restart on|off\ndefault: lua_sa_restart on\ncontext: http\nWhen enabled, this module will set the SA_RESTART flag on nginx workers signal dispositions.\nThis allows Lua I/O primitives to not be interrupted by nginx\u0026rsquo;s handling of various signals.\nThis directive was first introduced in the v0.10.14 release.\nBack to TOC\nNginx API for Lua  Introduction ngx.arg ngx.var.VARIABLE Core constants HTTP method constants HTTP status constants Nginx log level constants print ngx.ctx ngx.location.capture ngx.location.capture_multi ngx.status ngx.header.HEADER ngx.resp.get_headers ngx.req.is_internal ngx.req.start_time ngx.req.http_version ngx.req.raw_header ngx.req.get_method ngx.req.set_method ngx.req.set_uri ngx.req.set_uri_args ngx.req.get_uri_args ngx.req.get_post_args ngx.req.get_headers ngx.req.set_header ngx.req.clear_header ngx.req.read_body ngx.req.discard_body ngx.req.get_body_data ngx.req.get_body_file ngx.req.set_body_data ngx.req.set_body_file ngx.req.init_body ngx.req.append_body ngx.req.finish_body ngx.req.socket ngx.exec ngx.redirect ngx.send_headers ngx.headers_sent ngx.print ngx.say ngx.log ngx.flush ngx.exit ngx.eof ngx.sleep ngx.escape_uri ngx.unescape_uri ngx.encode_args ngx.decode_args ngx.encode_base64 ngx.decode_base64 ngx.crc32_short ngx.crc32_long ngx.hmac_sha1 ngx.md5 ngx.md5_bin ngx.sha1_bin ngx.quote_sql_str ngx.today ngx.time ngx.now ngx.update_time ngx.localtime ngx.utctime ngx.cookie_time ngx.http_time ngx.parse_http_time ngx.is_subrequest ngx.re.match ngx.re.find ngx.re.gmatch ngx.re.sub ngx.re.gsub ngx.shared.DICT ngx.shared.DICT.get ngx.shared.DICT.get_stale ngx.shared.DICT.set ngx.shared.DICT.safe_set ngx.shared.DICT.add ngx.shared.DICT.safe_add ngx.shared.DICT.replace ngx.shared.DICT.delete ngx.shared.DICT.incr ngx.shared.DICT.lpush ngx.shared.DICT.rpush ngx.shared.DICT.lpop ngx.shared.DICT.rpop ngx.shared.DICT.llen ngx.shared.DICT.ttl ngx.shared.DICT.expire ngx.shared.DICT.flush_all ngx.shared.DICT.flush_expired ngx.shared.DICT.get_keys ngx.shared.DICT.capacity ngx.shared.DICT.free_space ngx.socket.udp udpsock:setpeername udpsock:send udpsock:receive udpsock:close udpsock:settimeout ngx.socket.stream ngx.socket.tcp tcpsock:connect tcpsock:sslhandshake tcpsock:send tcpsock:receive tcpsock:receiveany tcpsock:receiveuntil tcpsock:close tcpsock:settimeout tcpsock:settimeouts tcpsock:setoption tcpsock:setkeepalive tcpsock:getreusedtimes ngx.socket.connect ngx.get_phase ngx.thread.spawn ngx.thread.wait ngx.thread.kill ngx.on_abort ngx.timer.at ngx.timer.every ngx.timer.running_count ngx.timer.pending_count ngx.config.subsystem ngx.config.debug ngx.config.prefix ngx.config.nginx_version ngx.config.nginx_configure ngx.config.ngx_lua_version ngx.worker.exiting ngx.worker.pid ngx.worker.count ngx.worker.id ngx.semaphore ngx.balancer ngx.ssl ngx.ocsp ndk.set_var.DIRECTIVE coroutine.create coroutine.resume coroutine.yield coroutine.wrap coroutine.running coroutine.status  Back to TOC\nIntroduction The various *_by_lua, *_by_lua_block and *_by_lua_file configuration directives serve as gateways to the Lua API within the nginx.conf file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.\nThe API is exposed to Lua in the form of two standard packages ngx and ndk. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.\nThe packages can be introduced into external Lua modules like this:\nlocal say = ngx.say local _M = {} function _M.foo(a) say(a) end return _M Use of the package.seeall flag is strongly discouraged due to its various bad side-effects.\nIt is also possible to directly require the packages in external Lua modules:\nlocal ngx = require \u0026#34;ngx\u0026#34; local ndk = require \u0026#34;ndk\u0026#34; The ability to require these packages was introduced in the v0.2.1rc19 release.\nNetwork I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua io library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx\u0026rsquo;s subrequests (via the ngx.location.capture method and similar) is strongly recommended for maximum performance.\nBack to TOC\nngx.arg syntax: val = ngx.arg[index]\ncontext: set_by_lua\u0026#42;, body_filter_by_lua\u0026#42;\nWhen this is used in the context of the set_by_lua* directives, this table is read-only and holds the input arguments to the config directives:\nvalue = ngx.arg[n] Here is an example\nlocation /foo { set $a 32; set $b 56; set_by_lua $sum \u0026#39;return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])\u0026#39; $a $b; echo $sum; } that writes out 88, the sum of 32 and 56.\nWhen this table is used in the context of body_filter_by_lua*, the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the \u0026ldquo;eof\u0026rdquo; flag indicating the end of the whole output data stream.\nThe data chunk and \u0026ldquo;eof\u0026rdquo; flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting nil or an empty Lua string value to ngx.arg[1], no data chunk will be passed to the downstream Nginx output filters at all.\nBack to TOC\nngx.var.VARIABLE syntax: ngx.var.VAR_NAME\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;\nRead and write Nginx variable values.\nvalue = ngx.var.some_nginx_variable_name ngx.var.some_nginx_variable_name = value Note that only already defined nginx variables can be written to. For example:\nlocation /foo { set $my_var \u0026#39;\u0026#39;; # this line is required to create $my_var at config time  content_by_lua_block { ngx.var.my_var = 123; ... } } That is, nginx variables cannot be created on-the-fly.\nSome special nginx variables like $args and $limit_rate can be assigned a value, many others are not, like $query_string, $arg_PARAMETER, and $http_NAME.\nNginx regex group capturing variables $1, $2, $3, and etc, can be read by this interface as well, by writing ngx.var[1], ngx.var[2], ngx.var[3], and etc.\nSetting ngx.var.Foo to a nil value will unset the $Foo Nginx variable.\nngx.var.args = nil CAUTION When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,\nlocal val = ngx.var.some_var --- use the val repeatedly later to prevent (temporary) memory leaking within the current request\u0026rsquo;s lifetime. Another way of caching the result is to use the ngx.ctx table.\nUndefined NGINX variables are evaluated to nil while uninitialized (but defined) NGINX variables are evaluated to an empty Lua string.\nThis API requires a relatively expensive metamethod call and it is recommended to avoid using it on hot code paths.\nBack to TOC\nCore constants context: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, \u0026#42;log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nngx.OK (0) ngx.ERROR (-1) ngx.AGAIN (-2) ngx.DONE (-4) ngx.DECLINED (-5) Note that only three of these constants are utilized by the Nginx API for Lua (i.e., ngx.exit accepts ngx.OK, ngx.ERROR, and ngx.DECLINED as input).\nngx.null The ngx.null constant is a NULL light userdata usually used to represent nil values in Lua tables etc and is similar to the lua-cjson library\u0026rsquo;s cjson.null constant. This constant was first introduced in the v0.5.0rc5 release.\nThe ngx.DECLINED constant was first introduced in the v0.5.0rc19 release.\nBack to TOC\nHTTP method constants context: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\n ngx.HTTP_GET ngx.HTTP_HEAD ngx.HTTP_PUT ngx.HTTP_POST ngx.HTTP_DELETE ngx.HTTP_OPTIONS (added in the v0.5.0rc24 release) ngx.HTTP_MKCOL (added in the v0.8.2 release) ngx.HTTP_COPY (added in the v0.8.2 release) ngx.HTTP_MOVE (added in the v0.8.2 release) ngx.HTTP_PROPFIND (added in the v0.8.2 release) ngx.HTTP_PROPPATCH (added in the v0.8.2 release) ngx.HTTP_LOCK (added in the v0.8.2 release) ngx.HTTP_UNLOCK (added in the v0.8.2 release) ngx.HTTP_PATCH (added in the v0.8.2 release) ngx.HTTP_TRACE (added in the v0.8.2 release)  These constants are usually used in ngx.location.capture and ngx.location.capture_multi method calls.\nBack to TOC\nHTTP status constants context: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nvalue = ngx.HTTP_CONTINUE (100) (first added in the v0.9.20 release) value = ngx.HTTP_SWITCHING_PROTOCOLS (101) (first added in the v0.9.20 release) value = ngx.HTTP_OK (200) value = ngx.HTTP_CREATED (201) value = ngx.HTTP_ACCEPTED (202) (first added in the v0.9.20 release) value = ngx.HTTP_NO_CONTENT (204) (first added in the v0.9.20 release) value = ngx.HTTP_PARTIAL_CONTENT (206) (first added in the v0.9.20 release) value = ngx.HTTP_SPECIAL_RESPONSE (300) value = ngx.HTTP_MOVED_PERMANENTLY (301) value = ngx.HTTP_MOVED_TEMPORARILY (302) value = ngx.HTTP_SEE_OTHER (303) value = ngx.HTTP_NOT_MODIFIED (304) value = ngx.HTTP_TEMPORARY_REDIRECT (307) (first added in the v0.9.20 release) value = ngx.HTTP_PERMANENT_REDIRECT (308) value = ngx.HTTP_BAD_REQUEST (400) value = ngx.HTTP_UNAUTHORIZED (401) value = ngx.HTTP_PAYMENT_REQUIRED (402) (first added in the v0.9.20 release) value = ngx.HTTP_FORBIDDEN (403) value = ngx.HTTP_NOT_FOUND (404) value = ngx.HTTP_NOT_ALLOWED (405) value = ngx.HTTP_NOT_ACCEPTABLE (406) (first added in the v0.9.20 release) value = ngx.HTTP_REQUEST_TIMEOUT (408) (first added in the v0.9.20 release) value = ngx.HTTP_CONFLICT (409) (first added in the v0.9.20 release) value = ngx.HTTP_GONE (410) value = ngx.HTTP_UPGRADE_REQUIRED (426) (first added in the v0.9.20 release) value = ngx.HTTP_TOO_MANY_REQUESTS (429) (first added in the v0.9.20 release) value = ngx.HTTP_CLOSE (444) (first added in the v0.9.20 release) value = ngx.HTTP_ILLEGAL (451) (first added in the v0.9.20 release) value = ngx.HTTP_INTERNAL_SERVER_ERROR (500) value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501) value = ngx.HTTP_BAD_GATEWAY (502) (first added in the v0.9.20 release) value = ngx.HTTP_SERVICE_UNAVAILABLE (503) value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release) value = ngx.HTTP_VERSION_NOT_SUPPORTED (505) (first added in the v0.9.20 release) value = ngx.HTTP_INSUFFICIENT_STORAGE (507) (first added in the v0.9.20 release) Back to TOC\nNginx log level constants context: init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nngx.STDERR ngx.EMERG ngx.ALERT ngx.CRIT ngx.ERR ngx.WARN ngx.NOTICE ngx.INFO ngx.DEBUG These constants are usually used by the ngx.log method.\nBack to TOC\nprint syntax: print(\u0026hellip;)\ncontext: init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nWrites argument values into the nginx error.log file with the ngx.NOTICE log level.\nIt is equivalent to\nngx.log(ngx.NOTICE, ...) Lua nil arguments are accepted and result in literal \u0026quot;nil\u0026quot; strings while Lua booleans result in literal \u0026quot;true\u0026quot; or \u0026quot;false\u0026quot; strings. And the ngx.null constant will yield the \u0026quot;null\u0026quot; string output.\nThere is a hard coded 2048 byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the NGX_MAX_ERROR_STR macro definition in the src/core/ngx_log.h file in the Nginx source tree.\nBack to TOC\nngx.ctx context: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;\nThis table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables).\nConsider the following example,\nlocation /test { rewrite_by_lua_block { ngx.ctx.foo = 76 } access_by_lua_block { ngx.ctx.foo = ngx.ctx.foo + 3 } content_by_lua_block { ngx.say(ngx.ctx.foo) } } Then GET /test will yield the output\n79 That is, the ngx.ctx.foo entry persists across the rewrite, access, and content phases of a request.\nEvery request, including subrequests, has its own copy of the table. For example:\nlocation /sub { content_by_lua_block { ngx.say(\u0026#34;sub pre: \u0026#34;, ngx.ctx.blah) ngx.ctx.blah = 32 ngx.say(\u0026#34;sub post: \u0026#34;, ngx.ctx.blah) } } location /main { content_by_lua_block { ngx.ctx.blah = 73 ngx.say(\u0026#34;main pre: \u0026#34;, ngx.ctx.blah) local res = ngx.location.capture(\u0026#34;/sub\u0026#34;) ngx.print(res.body) ngx.say(\u0026#34;main post: \u0026#34;, ngx.ctx.blah) } } Then GET /main will give the output\nmain pre: 73 sub pre: nil sub post: 32 main post: 73 Here, modification of the ngx.ctx.blah entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of ngx.ctx.blah.\nInternal redirection will destroy the original request ngx.ctx data (if any) and the new request will have an empty ngx.ctx table. For instance,\nlocation /new { content_by_lua_block { ngx.say(ngx.ctx.foo) } } location /orig { content_by_lua_block { ngx.ctx.foo = \u0026#34;hello\u0026#34; ngx.exec(\u0026#34;/new\u0026#34;) } } Then GET /orig will give\nnil rather than the original \u0026quot;hello\u0026quot; value.\nArbitrary data values, including Lua closures and nested tables, can be inserted into this \u0026ldquo;magic\u0026rdquo; table. It also allows the registration of custom meta methods.\nOverriding ngx.ctx with a new Lua table is also supported, for example,\nngx.ctx = { foo = 32, bar = 54 } When being used in the context of init_worker_by_lua*, this table just has the same lifetime of the current Lua handler.\nThe ngx.ctx lookup requires relatively expensive metamethod calls and it is much slower than explicitly passing per-request data along by your own function arguments. So do not abuse this API for saving your own function arguments because it usually has quite some performance impact.\nBecause of the metamethod magic, never \u0026ldquo;local\u0026rdquo; the ngx.ctx table outside your Lua function scope on the Lua module level due to worker-level data sharing. For example, the following is bad:\n-- mymodule.lua local _M = {} -- the following line is bad since ngx.ctx is a per-request -- data while this \u0026lt;code\u0026gt;ctx\u0026lt;/code\u0026gt; variable is on the Lua module level -- and thus is per-nginx-worker. local ctx = ngx.ctx function _M.main() ctx.foo = \u0026#34;bar\u0026#34; end return _M Use the following instead:\n-- mymodule.lua local _M = {} function _M.main(ctx) ctx.foo = \u0026#34;bar\u0026#34; end return _M That is, let the caller pass the ctx table explicitly via a function argument.\nBack to TOC\nngx.location.capture syntax: res = ngx.location.capture(uri, options?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nIssues a synchronous but still non-blocking Nginx Subrequest using uri.\nNginx\u0026rsquo;s subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or any other nginx C modules like ngx_proxy, ngx_fastcgi, ngx_memc, ngx_postgres, ngx_drizzle, and even ngx_lua itself and etc etc etc.\nAlso note that subrequests just mimic the HTTP interface but there is no extra HTTP/TCP traffic nor IPC involved. Everything works internally, efficiently, on the C level.\nSubrequests are completely different from HTTP 301\u0026frasl;302 redirection (via ngx.redirect) and internal redirection (via ngx.exec).\nYou should always read the request body (by either calling ngx.req.read_body or configuring lua_need_request_body on) before initiating a subrequest.\nThis API function (as well as ngx.location.capture_multi) always buffers the whole response body of the subrequest in memory. Thus, you should use cosockets and streaming processing instead if you have to handle large subrequest responses.\nHere is a basic example:\nres = ngx.location.capture(uri) Returns a Lua table with 4 slots: res.status, res.header, res.body, and res.truncated.\nres.status holds the response status code for the subrequest response.\nres.header holds all the response headers of the subrequest and it is a normal Lua table. For multi-value response headers, the value is a Lua (array) table that holds all the values in the order that they appear. For instance, if the subrequest response headers contain the following lines:\nSet-Cookie: a=3 Set-Cookie: foo=bar Set-Cookie: baz=blah Then res.header[\u0026quot;Set-Cookie\u0026quot;] will be evaluated to the table value {\u0026quot;a=3\u0026quot;, \u0026quot;foo=bar\u0026quot;, \u0026quot;baz=blah\u0026quot;}.\nres.body holds the subrequest\u0026rsquo;s response body data, which might be truncated. You always need to check the res.truncated boolean flag to see if res.body contains truncated data. The data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote.\nURI query strings can be concatenated to URI itself, for instance,\nres = ngx.location.capture(\u0026#39;/foo/bar?a=3\u0026amp;b=4\u0026#39;) Named locations like @foo are not allowed due to a limitation in the nginx core. Use normal locations combined with the internal directive to prepare internal-only locations.\nAn optional option table can be fed as the second argument, which supports the options:\n method specify the subrequest\u0026rsquo;s request method, which only accepts constants like ngx.HTTP_POST. body specify the subrequest\u0026rsquo;s request body (string value only). args specify the subrequest\u0026rsquo;s URI query arguments (both string value and Lua tables are accepted) ctx specify a Lua table to be the ngx.ctx table for the subrequest. It can be the current request\u0026rsquo;s ngx.ctx table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the v0.3.1rc25 release. vars take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option\u0026rsquo;s value. This option was first introduced in the v0.3.1rc31 release. copy_all_vars specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the v0.3.1rc31 release. share_all_vars specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request. Enabling this option may lead to hard-to-debug issues due to bad side-effects and is considered bad and harmful. Only enable this option when you completely know what you are doing. always_forward_body when set to true, the current (parent) request\u0026rsquo;s request body will always be forwarded to the subrequest being created if the body option is not specified. The request body read by either ngx.req.read_body() or lua_need_request_body on will be directly forwarded to the subrequest without copying the whole request body data when creating the subrequest (no matter the request body data is buffered in memory buffers or temporary files). By default, this option is false and when the body option is not specified, the request body of the current (parent) request is only forwarded when the subrequest takes the PUT or POST request method.  Issuing a POST subrequest, for example, can be done as follows\nres = ngx.location.capture( \u0026#39;/foo/bar\u0026#39;, { method = ngx.HTTP_POST, body = \u0026#39;hello, world\u0026#39; } ) See HTTP method constants methods other than POST. The method option is ngx.HTTP_GET by default.\nThe args option can specify extra URI arguments, for instance,\nngx.location.capture(\u0026#39;/foo?a=1\u0026#39;, { args = { b = 3, c = \u0026#39;:\u0026#39; } } ) is equivalent to\nngx.location.capture(\u0026#39;/foo?a=1\u0026amp;b=3\u0026amp;c=%3a\u0026#39;) that is, this method will escape argument keys and values according to URI rules and concatenate them together into a complete query string. The format for the Lua table passed as the args argument is identical to the format used in the ngx.encode_args method.\nThe args option can also take plain query strings:\nngx.location.capture(\u0026#39;/foo?a=1\u0026#39;, { args = \u0026#39;b=3\u0026amp;c=%3a\u0026#39; } ) This is functionally identical to the previous examples.\nThe share_all_vars option controls whether to share nginx variables among the current request and its subrequests. If this option is set to true, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.\nCare should be taken in using this option as variable scope sharing can have unexpected side effects. The args, vars, or copy_all_vars options are generally preferable instead.\nThis option is set to false by default\nlocation /other { set $dog \u0026#34;$dog world\u0026#34;; echo \u0026#34;$uri dog: $dog\u0026#34;; } location /lua { set $dog \u0026#39;hello\u0026#39;; content_by_lua_block { res = ngx.location.capture(\u0026#34;/other\u0026#34;, { share_all_vars = true }); ngx.print(res.body) ngx.say(ngx.var.uri, \u0026#34;: \u0026#34;, ngx.var.dog) } } Accessing location /lua gives\n/other dog: hello world /lua: hello world  The copy_all_vars option provides a copy of the parent request\u0026rsquo;s Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request\u0026rsquo;s variables.\nlocation /other { set $dog \u0026#34;$dog world\u0026#34;; echo \u0026#34;$uri dog: $dog\u0026#34;; } location /lua { set $dog \u0026#39;hello\u0026#39;; content_by_lua_block { res = ngx.location.capture(\u0026#34;/other\u0026#34;, { copy_all_vars = true }); ngx.print(res.body) ngx.say(ngx.var.uri, \u0026#34;: \u0026#34;, ngx.var.dog) } } Request GET /lua will give the output\n/other dog: hello world /lua: hello  Note that if both share_all_vars and copy_all_vars are set to true, then share_all_vars takes precedence.\nIn addition to the two settings above, it is possible to specify values for variables in the subrequest using the vars option. These variables are set after the sharing or copying of variables has been evaluated, and provides a more efficient method of passing specific values to a subrequest over encoding them as URL arguments and unescaping them in the Nginx config file.\nlocation /other { content_by_lua_block { ngx.say(\u0026#34;dog = \u0026#34;, ngx.var.dog) ngx.say(\u0026#34;cat = \u0026#34;, ngx.var.cat) } } location /lua { set $dog \u0026#39;\u0026#39;; set $cat \u0026#39;\u0026#39;; content_by_lua_block { res = ngx.location.capture(\u0026#34;/other\u0026#34;, { vars = { dog = \u0026#34;hello\u0026#34;, cat = 32 }}); ngx.print(res.body) } } Accessing /lua will yield the output\ndog = hello cat = 32  The ctx option can be used to specify a custom Lua table to serve as the ngx.ctx table for the subrequest.\nlocation /sub { content_by_lua_block { ngx.ctx.foo = \u0026#34;bar\u0026#34;; } } location /lua { content_by_lua_block { local ctx = {} res = ngx.location.capture(\u0026#34;/sub\u0026#34;, { ctx = ctx }) ngx.say(ctx.foo); ngx.say(ngx.ctx.foo); } } Then request GET /lua gives\nbar nil  It is also possible to use this ctx option to share the same ngx.ctx table between the current (parent) request and the subrequest:\nlocation /sub { content_by_lua_block { ngx.ctx.foo = \u0026#34;bar\u0026#34;; } } location /lua { content_by_lua_block { res = ngx.location.capture(\u0026#34;/sub\u0026#34;, { ctx = ngx.ctx }) ngx.say(ngx.ctx.foo); } } Request GET /lua yields the output\nbar  Note that subrequests issued by ngx.location.capture inherit all the request headers of the current request by default and that this may have unexpected side effects on the subrequest responses. For example, when using the standard ngx_proxy module to serve subrequests, an \u0026ldquo;Accept-Encoding: gzip\u0026rdquo; header in the main request may result in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting proxy_pass_request_headers to off in subrequest locations.\nWhen the body option is not specified and the always_forward_body option is false (the default value), the POST and PUT subrequests will inherit the request bodies of the parent request (if any).\nThere is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was 50 concurrent subrequests and in more recent versions, Nginx 1.1.x onwards, this was increased to 200 concurrent subrequests. When this limit is exceeded, the following error message is added to the error.log file:\n[error] 13983#0: *1 subrequests cycle while processing \u0026quot;/uri\u0026quot;  The limit can be manually modified if required by editing the definition of the NGX_HTTP_MAX_SUBREQUESTS macro in the nginx/src/http/ngx_http_request.h file in the Nginx source tree.\nPlease also refer to restrictions on capturing locations configured by subrequest directives of other modules.\nBack to TOC\nngx.location.capture_multi syntax: res1, res2, \u0026hellip; = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, \u0026hellip; })\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nJust like ngx.location.capture, but supports multiple subrequests running in parallel.\nThis function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,\nres1, res2, res3 = ngx.location.capture_multi{ { \u0026#34;/foo\u0026#34;, { args = \u0026#34;a=3\u0026amp;b=4\u0026#34; } }, { \u0026#34;/bar\u0026#34; }, { \u0026#34;/baz\u0026#34;, { method = ngx.HTTP_POST, body = \u0026#34;hello\u0026#34; } }, } if res1.status == ngx.HTTP_OK then ... end if res2.body == \u0026#34;BLAH\u0026#34; then ... end This function will not return until all the subrequests terminate. The total latency is the longest latency of the individual subrequests rather than the sum.\nLua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:\n-- construct the requests table local reqs = {} table.insert(reqs, { \u0026#34;/mysql\u0026#34; }) table.insert(reqs, { \u0026#34;/postgres\u0026#34; }) table.insert(reqs, { \u0026#34;/redis\u0026#34; }) table.insert(reqs, { \u0026#34;/memcached\u0026#34; }) -- issue all the requests at once and wait until they all return local resps = { ngx.location.capture_multi(reqs) } -- loop over the responses table for i, resp in ipairs(resps) do -- process the response table \u0026#34;resp\u0026#34; end The ngx.location.capture function is just a special form of this function. Logically speaking, the ngx.location.capture can be implemented like this\nngx.location.capture = function (uri, args) return ngx.location.capture_multi({ {uri, args} }) end Please also refer to restrictions on capturing locations configured by subrequest directives of other modules.\nBack to TOC\nngx.status context: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;\nRead and write the current request\u0026rsquo;s response status. This should be called before sending out the response headers.\nngx.status = ngx.HTTP_CREATED status = ngx.status Setting ngx.status after the response header is sent out has no effect but leaving an error message in your nginx\u0026rsquo;s error log file:\nattempt to set ngx.status after sending out response headers  Back to TOC\nngx.header.HEADER syntax: ngx.header.HEADER = VALUE\nsyntax: value = ngx.header.HEADER\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;\nSet, add to, or clear the current request\u0026rsquo;s HEADER response header that is to be sent.\nUnderscores (_) in the header names will be replaced by hyphens (-) by default. This transformation can be turned off via the lua_transform_underscores_in_response_headers directive.\nThe header names are matched case-insensitively.\n-- equivalent to ngx.header[\u0026#34;Content-Type\u0026#34;] = \u0026#39;text/plain\u0026#39; ngx.header.content_type = \u0026#39;text/plain\u0026#39;; ngx.header[\u0026#34;X-My-Header\u0026#34;] = \u0026#39;blah blah\u0026#39;; Multi-value headers can be set this way:\nngx.header[\u0026#39;Set-Cookie\u0026#39;] = {\u0026#39;a=32; path=/\u0026#39;, \u0026#39;b=4; path=/\u0026#39;} will yield\nSet-Cookie: a=32; path=/ Set-Cookie: b=4; path=/ in the response headers.\nOnly Lua tables are accepted (Only the last element in the table will take effect for standard headers such as Content-Type that only accept a single value).\nngx.header.content_type = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;} is equivalent to\nngx.header.content_type = \u0026#39;b\u0026#39; Setting a slot to nil effectively removes it from the response headers:\nngx.header[\u0026#34;X-My-Header\u0026#34;] = nil; The same applies to assigning an empty table:\nngx.header[\u0026#34;X-My-Header\u0026#34;] = {}; Setting ngx.header.HEADER after sending out response headers (either explicitly with ngx.send_headers or implicitly with ngx.print and similar) will log an error message.\nReading ngx.header.HEADER will return the value of the response header named HEADER.\nUnderscores (_) in the header names will also be replaced by dashes (-) and the header names will be matched case-insensitively. If the response header is not present at all, nil will be returned.\nThis is particularly useful in the context of header_filter_by_lua*, for example,\nlocation /test { set $footer \u0026#39;\u0026#39;; proxy_pass http://some-backend; header_filter_by_lua_block { if ngx.header[\u0026#34;X-My-Header\u0026#34;] == \u0026#34;blah\u0026#34; then ngx.var.footer = \u0026#34;some value\u0026#34; end } echo_after_body $footer; } For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers\nFoo: bar Foo: baz  will result in\n{\u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;} to be returned when reading ngx.header.Foo.\nNote that ngx.header is not a normal Lua table and as such, it is not possible to iterate through it using the Lua ipairs function.\nFor reading request headers, use the ngx.req.get_headers function instead.\nBack to TOC\nngx.resp.get_headers syntax: headers, err = ngx.resp.get_headers(max_headers?, raw?)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, balancer_by_lua\u0026#42;\nReturns a Lua table holding all the current response headers for the current request.\nlocal h, err = ngx.resp.get_headers() if err == \u0026#34;truncated\u0026#34; then -- one can choose to ignore or reject the current response here end for k, v in pairs(h) do ... end This function has the same signature as ngx.req.get_headers except getting response headers instead of request headers.\nNote that a maximum of 100 response headers are parsed by default (including those with the same name) and that additional response headers are silently discarded to guard against potential denial of service attacks. Since v0.10.13, when the limit is exceeded, it will return a second value which is the string \u0026quot;truncated\u0026quot;.\nThis API was first introduced in the v0.9.5 release.\nBack to TOC\nngx.req.is_internal syntax: is_internal = ngx.req.is_internal()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;\nReturns a boolean indicating whether the current request is an \u0026ldquo;internal request\u0026rdquo;, i.e., a request initiated from inside the current nginx server instead of from the client side.\nSubrequests are all internal requests and so are requests after internal redirects.\nThis API was first introduced in the v0.9.20 release.\nBack to TOC\nngx.req.start_time syntax: secs = ngx.req.start_time()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;\nReturns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.\nThe following example emulates the $request_time variable value (provided by ngx_http_log_module) in pure Lua:\nlocal request_time = ngx.now() - ngx.req.start_time() This function was first introduced in the v0.7.7 release.\nSee also ngx.now and ngx.update_time.\nBack to TOC\nngx.req.http_version syntax: num = ngx.req.http_version()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;\nReturns the HTTP version number for the current request as a Lua number.\nCurrent possible values are 2.0, 1.0, 1.1, and 0.9. Returns nil for unrecognized values.\nThis method was first introduced in the v0.7.17 release.\nBack to TOC\nngx.req.raw_header syntax: str = ngx.req.raw_header(no_request_line?)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;\nReturns the original raw HTTP protocol header received by the Nginx server.\nBy default, the request line and trailing CR LF terminator will also be included. For example,\nngx.print(ngx.req.raw_header()) gives something like this:\nGET /t HTTP/1.1 Host: localhost Connection: close Foo: bar  You can specify the optional no_request_line argument as a true value to exclude the request line from the result. For example,\nngx.print(ngx.req.raw_header(true)) outputs something like this:\nHost: localhost Connection: close Foo: bar  This method was first introduced in the v0.7.17 release.\nThis method does not work in HTTP/2 requests yet.\nBack to TOC\nngx.req.get_method syntax: method_name = ngx.req.get_method()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, balancer_by_lua\u0026#42;, log_by_lua\u0026#42;\nRetrieves the current request\u0026rsquo;s request method name. Strings like \u0026quot;GET\u0026quot; and \u0026quot;POST\u0026quot; are returned instead of numerical method constants.\nIf the current request is an Nginx subrequest, then the subrequest\u0026rsquo;s method name will be returned.\nThis method was first introduced in the v0.5.6 release.\nSee also ngx.req.set_method.\nBack to TOC\nngx.req.set_method syntax: ngx.req.set_method(method_id)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;\nOverrides the current request\u0026rsquo;s request method with the method_id argument. Currently only numerical method constants are supported, like ngx.HTTP_POST and ngx.HTTP_GET.\nIf the current request is an Nginx subrequest, then the subrequest\u0026rsquo;s method will be overridden.\nThis method was first introduced in the v0.5.6 release.\nSee also ngx.req.get_method.\nBack to TOC\nngx.req.set_uri syntax: ngx.req.set_uri(uri, jump?)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;\nRewrite the current request\u0026rsquo;s (parsed) URI by the uri argument. The uri argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.\nThe optional boolean jump argument can trigger location rematch (or location jump) as ngx_http_rewrite_module\u0026rsquo;s rewrite directive, that is, when jump is true (default to false), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later post-rewrite phase and jumping to the new location.\nLocation jump will not be triggered otherwise, and only the current request\u0026rsquo;s URI will be modified, which is also the default behavior. This function will return but with no returned values when the jump argument is false or absent altogether.\nFor example, the following nginx config snippet\nrewrite ^ /foo last; can be coded in Lua like this:\nngx.req.set_uri(\u0026#34;/foo\u0026#34;, true) Similarly, Nginx config\nrewrite ^ /foo break; can be coded in Lua as\nngx.req.set_uri(\u0026#34;/foo\u0026#34;, false) or equivalently,\nngx.req.set_uri(\u0026#34;/foo\u0026#34;) The jump argument can only be set to true in rewrite_by_lua*. Use of jump in other contexts is prohibited and will throw out a Lua exception.\nA more sophisticated example involving regex substitutions is as follows\nlocation /test { rewrite_by_lua_block { local uri = ngx.re.sub(ngx.var.uri, \u0026#34;^/test/(.*)\u0026#34;, \u0026#34;/$1\u0026#34;, \u0026#34;o\u0026#34;) ngx.req.set_uri(uri) } proxy_pass http://my_backend; } which is functionally equivalent to\nlocation /test { rewrite ^/test/(.*) /$1 break; proxy_pass http://my_backend; } Note that it is not possible to use this interface to rewrite URI arguments and that ngx.req.set_uri_args should be used for this instead. For instance, Nginx config\nrewrite ^ /foo?a=3? last; can be coded as\nngx.req.set_uri_args(\u0026#34;a=3\u0026#34;) ngx.req.set_uri(\u0026#34;/foo\u0026#34;, true) or\nngx.req.set_uri_args({a = 3}) ngx.req.set_uri(\u0026#34;/foo\u0026#34;, true) This interface was first introduced in the v0.3.1rc14 release.\nBack to TOC\nngx.req.set_uri_args syntax: ngx.req.set_uri_args(args)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;\nRewrite the current request\u0026rsquo;s URI query arguments by the args argument. The args argument can be either a Lua string, as in\nngx.req.set_uri_args(\u0026#34;a=3\u0026amp;b=hello%20world\u0026#34;) or a Lua table holding the query arguments\u0026rsquo; key-value pairs, as in\nngx.req.set_uri_args({ a = 3, b = \u0026#34;hello world\u0026#34; }) where in the latter case, this method will escape argument keys and values according to the URI escaping rule.\nMulti-value arguments are also supported:\nngx.req.set_uri_args({ a = 3, b = {5, 6} }) which will result in a query string like a=3\u0026amp;b=5\u0026amp;b=6.\nThis interface was first introduced in the v0.3.1rc13 release.\nSee also ngx.req.set_uri.\nBack to TOC\nngx.req.get_uri_args syntax: args, err = ngx.req.get_uri_args(max_args?)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, balancer_by_lua\u0026#42;\nReturns a Lua table holding all the current request URL query arguments.\nlocation = /test { content_by_lua_block { local args, err = ngx.req.get_uri_args() if err == \u0026#34;truncated\u0026#34; then -- one can choose to ignore or reject the current request here end for key, val in pairs(args) do if type(val) == \u0026#34;table\u0026#34; then ngx.say(key, \u0026#34;: \u0026#34;, table.concat(val, \u0026#34;, \u0026#34;)) else ngx.say(key, \u0026#34;: \u0026#34;, val) end end } } Then GET /test?foo=bar\u0026amp;bar=baz\u0026amp;bar=blah will yield the response body\nfoo: bar bar: baz, blah Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.\nKeys and values are unescaped according to URI escaping rules. In the settings above, GET /test?a%20b=1%61+2 will yield:\na b: 1a 2 Arguments without the =\u0026lt;value\u0026gt; parts are treated as boolean arguments. GET /test?foo\u0026amp;bar will yield:\nfoo: true bar: true That is, they will take Lua boolean values true. However, they are different from arguments taking empty string values. GET /test?foo=\u0026amp;bar= will give something like\nfoo: bar: Empty key arguments are discarded. GET /test?=hello\u0026amp;=world will yield an empty output for instance.\nUpdating query arguments via the nginx variable $args (or ngx.var.args in Lua) at runtime is also supported:\nngx.var.args = \u0026#34;a=3\u0026amp;b=42\u0026#34; local args, err = ngx.req.get_uri_args() Here the args table will always look like\n{a = 3, b = 42} regardless of the actual request query string.\nNote that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since v0.10.13, when the limit is exceeded, it will return a second value which is the string \u0026quot;truncated\u0026quot;.\nHowever, the optional max_args function argument can be used to override this limit:\nlocal args, err = ngx.req.get_uri_args(10) if err == \u0026#34;truncated\u0026#34; then -- one can choose to ignore or reject the current request here end This argument can be set to zero to remove the limit and to process all request arguments received:\nlocal args, err = ngx.req.get_uri_args(0) Removing the max_args cap is strongly discouraged.\nBack to TOC\nngx.req.get_post_args syntax: args, err = ngx.req.get_post_args(max_args?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;\nReturns a Lua table holding all the current request POST query arguments (of the MIME type application/x-www-form-urlencoded). Call ngx.req.read_body to read the request body first or turn on the lua_need_request_body directive to avoid errors.\nlocation = /test { content_by_lua_block { ngx.req.read_body() local args, err = ngx.req.get_post_args() if err == \u0026#34;truncated\u0026#34; then -- one can choose to ignore or reject the current request here end if not args then ngx.say(\u0026#34;failed to get post args: \u0026#34;, err) return end for key, val in pairs(args) do if type(val) == \u0026#34;table\u0026#34; then ngx.say(key, \u0026#34;: \u0026#34;, table.concat(val, \u0026#34;, \u0026#34;)) else ngx.say(key, \u0026#34;: \u0026#34;, val) end end } } Then\n# Post request with the body \u0026#39;foo=bar\u0026amp;bar=baz\u0026amp;bar=blah\u0026#39; $ curl --data \u0026#39;foo=bar\u0026amp;bar=baz\u0026amp;bar=blah\u0026#39; localhost/test will yield the response body like\nfoo: bar bar: baz, blah Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.\nKeys and values will be unescaped according to URI escaping rules.\nWith the settings above,\n# POST request with body \u0026#39;a%20b=1%61+2\u0026#39; $ curl -d \u0026#39;a%20b=1%61+2\u0026#39; localhost/test will yield:\na b: 1a 2 Arguments without the =\u0026lt;value\u0026gt; parts are treated as boolean arguments. POST /test with the request body foo\u0026amp;bar will yield:\nfoo: true bar: true That is, they will take Lua boolean values true. However, they are different from arguments taking empty string values. POST /test with request body foo=\u0026amp;bar= will return something like\nfoo: bar: Empty key arguments are discarded. POST /test with body =hello\u0026amp;=world will yield empty outputs for instance.\nNote that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since v0.10.13, when the limit is exceeded, it will return a second value which is the string \u0026quot;truncated\u0026quot;.\nHowever, the optional max_args function argument can be used to override this limit:\nlocal args, err = ngx.req.get_post_args(10) if err == \u0026#34;truncated\u0026#34; then -- one can choose to ignore or reject the current request here end This argument can be set to zero to remove the limit and to process all request arguments received:\nlocal args, err = ngx.req.get_post_args(0) Removing the max_args cap is strongly discouraged.\nBack to TOC\nngx.req.get_headers syntax: headers, err = ngx.req.get_headers(max_headers?, raw?)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;\nReturns a Lua table holding all the current request headers.\nlocal h, err = ngx.req.get_headers() if err == \u0026#34;truncated\u0026#34; then -- one can choose to ignore or reject the current request here end for k, v in pairs(h) do ... end To read an individual header:\nngx.say(\u0026#34;Host: \u0026#34;, ngx.req.get_headers()[\u0026#34;Host\u0026#34;]) Note that the ngx.var.HEADER API call, which uses core $http_HEADER variables, may be more preferable for reading individual request headers.\nFor multiple instances of request headers such as:\nFoo: foo Foo: bar Foo: baz the value of ngx.req.get_headers()[\u0026quot;Foo\u0026quot;] will be a Lua (array) table such as:\n{\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;} Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks. Since v0.10.13, when the limit is exceeded, it will return a second value which is the string \u0026quot;truncated\u0026quot;.\nHowever, the optional max_headers function argument can be used to override this limit:\nlocal headers, err = ngx.req.get_headers(10) if err == \u0026#34;truncated\u0026#34; then -- one can choose to ignore or reject the current request here end This argument can be set to zero to remove the limit and to process all request headers received:\nlocal headers, err = ngx.req.get_headers(0) Removing the max_headers cap is strongly discouraged.\nSince the 0.6.9 release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the raw argument is set to true (default to false).\nAlso, by default, an __index metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header My-Foo-Header is present, then the following invocations will all pick up the value of this header correctly:\nngx.say(headers.my_foo_header) ngx.say(headers[\u0026#34;My-Foo-Header\u0026#34;]) ngx.say(headers[\u0026#34;my-foo-header\u0026#34;]) The __index metamethod will not be added when the raw argument is set to true.\nBack to TOC\nngx.req.set_header syntax: ngx.req.set_header(header_name, header_value)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;\nSet the current request\u0026rsquo;s request header named header_name to value header_value, overriding any existing ones.\nBy default, all the subrequests subsequently initiated by ngx.location.capture and ngx.location.capture_multi will inherit the new header.\nHere is an example of setting the Content-Type header:\nngx.req.set_header(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/css\u0026#34;) The header_value can take an array list of values, for example,\nngx.req.set_header(\u0026#34;Foo\u0026#34;, {\u0026#34;a\u0026#34;, \u0026#34;abc\u0026#34;}) will produce two new request headers:\nFoo: a Foo: abc and old Foo headers will be overridden if there is any.\nWhen the header_value argument is nil, the request header will be removed. So\nngx.req.set_header(\u0026#34;X-Foo\u0026#34;, nil) is equivalent to\nngx.req.clear_header(\u0026#34;X-Foo\u0026#34;) Back to TOC\nngx.req.clear_header syntax: ngx.req.clear_header(header_name)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;\nClears the current request\u0026rsquo;s request header named header_name. None of the current request\u0026rsquo;s existing subrequests will be affected but subsequently initiated subrequests will inherit the change by default.\nBack to TOC\nngx.req.read_body syntax: ngx.req.read_body()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nReads the client request body synchronously without blocking the Nginx event loop.\nngx.req.read_body() local args = ngx.req.get_post_args() If the request body is already read previously by turning on lua_need_request_body or by using other modules, then this function does not run and returns immediately.\nIf the request body has already been explicitly discarded, either by the ngx.req.discard_body function or other modules, this function does not run and returns immediately.\nIn case of errors, such as connection errors while reading the data, this method will throw out a Lua exception or terminate the current request with a 500 status code immediately.\nThe request body data read using this function can be retrieved later via ngx.req.get_body_data or, alternatively, the temporary file name for the body data cached to disk using ngx.req.get_body_file. This depends on\n whether the current request body is already larger than the client_body_buffer_size, and whether client_body_in_file_only has been switched on.  In cases where current request may have a request body and the request body data is not required, The ngx.req.discard_body function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.\nThis function was first introduced in the v0.3.1rc17 release.\nBack to TOC\nngx.req.discard_body syntax: ngx.req.discard_body()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nExplicitly discard the request body, i.e., read the data on the connection and throw it away immediately (without using the request body by any means).\nThis function is an asynchronous call and returns immediately.\nIf the request body has already been read, this function does nothing and returns immediately.\nThis function was first introduced in the v0.3.1rc17 release.\nSee also ngx.req.read_body.\nBack to TOC\nngx.req.get_body_data syntax: data = ngx.req.get_body_data()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, log_by_lua\u0026#42;\nRetrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the ngx.req.get_post_args function instead if a Lua table is required.\nThis function returns nil if\n the request body has not been read, the request body has been read into disk temporary files, or the request body has zero size.  If the request body has not been read yet, call ngx.req.read_body first (or turn on lua_need_request_body to force this module to read the request body. This is not recommended however).\nIf the request body has been read into disk files, try calling the ngx.req.get_body_file function instead.\nTo force in-memory request bodies, try setting client_body_buffer_size to the same size value in client_max_body_size.\nNote that calling this function instead of using ngx.var.request_body or ngx.var.echo_request_body is more efficient because it can save one dynamic memory allocation and one data copy.\nThis function was first introduced in the v0.3.1rc17 release.\nSee also ngx.req.get_body_file.\nBack to TOC\nngx.req.get_body_file syntax: file_name = ngx.req.get_body_file()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nRetrieves the file name for the in-file request body data. Returns nil if the request body has not been read or has been read into memory.\nThe returned file is read only and is usually cleaned up by Nginx\u0026rsquo;s memory pool. It should not be manually modified, renamed, or removed in Lua code.\nIf the request body has not been read yet, call ngx.req.read_body first (or turn on lua_need_request_body to force this module to read the request body. This is not recommended however).\nIf the request body has been read into memory, try calling the ngx.req.get_body_data function instead.\nTo force in-file request bodies, try turning on client_body_in_file_only.\nThis function was first introduced in the v0.3.1rc17 release.\nSee also ngx.req.get_body_data.\nBack to TOC\nngx.req.set_body_data syntax: ngx.req.set_body_data(data)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nSet the current request\u0026rsquo;s request body using the in-memory data specified by the data argument.\nIf the request body has not been read yet, call ngx.req.read_body first (or turn on lua_need_request_body to force this module to read the request body. This is not recommended however). Additionally, the request body must not have been previously discarded by ngx.req.discard_body.\nWhether the previous request body has been read into memory or buffered into a disk file, it will be freed or the disk file will be cleaned up immediately, respectively.\nThis function was first introduced in the v0.3.1rc18 release.\nSee also ngx.req.set_body_file.\nBack to TOC\nngx.req.set_body_file syntax: ngx.req.set_body_file(file_name, auto_clean?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nSet the current request\u0026rsquo;s request body using the in-file data specified by the file_name argument.\nIf the request body has not been read yet, call ngx.req.read_body first (or turn on lua_need_request_body to force this module to read the request body. This is not recommended however). Additionally, the request body must not have been previously discarded by ngx.req.discard_body.\nIf the optional auto_clean argument is given a true value, then this file will be removed at request completion or the next time this function or ngx.req.set_body_data are called in the same request. The auto_clean is default to false.\nPlease ensure that the file specified by the file_name argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.\nWhether the previous request body has been read into memory or buffered into a disk file, it will be freed or the disk file will be cleaned up immediately, respectively.\nThis function was first introduced in the v0.3.1rc18 release.\nSee also ngx.req.set_body_data.\nBack to TOC\nngx.req.init_body syntax: ngx.req.init_body(buffer_size?)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nCreates a new blank request body for the current request and inializes the buffer for later request body data writing via the ngx.req.append_body and ngx.req.finish_body APIs.\nIf the buffer_size argument is specified, then its value will be used for the size of the memory buffer for body writing with ngx.req.append_body. If the argument is omitted, then the value specified by the standard client_body_buffer_size directive will be used instead.\nWhen the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.\nIt is important to always call the ngx.req.finish_body after all the data has been appended onto the current request body. Also, when this function is used together with ngx.req.socket, it is required to call ngx.req.socket before this function, or you will get the \u0026ldquo;request body already exists\u0026rdquo; error message.\nThe usage of this function is often like this:\nngx.req.init_body(128 * 1024) -- buffer is 128KB for chunk in next_data_chunk() do ngx.req.append_body(chunk) -- each chunk can be 4KB end ngx.req.finish_body() This function can be used with ngx.req.append_body, ngx.req.finish_body, and ngx.req.socket to implement efficient input filters in pure Lua (in the context of rewrite_by_lua* or access_by_lua*), which can be used with other Nginx content handler or upstream modules like ngx_http_proxy_module and ngx_http_fastcgi_module.\nThis function was first introduced in the v0.5.11 release.\nBack to TOC\nngx.req.append_body syntax: ngx.req.append_body(data_chunk)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nAppend new data chunk specified by the data_chunk argument onto the existing request body created by the ngx.req.init_body call.\nWhen the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.\nIt is important to always call the ngx.req.finish_body after all the data has been appended onto the current request body.\nThis function can be used with ngx.req.init_body, ngx.req.finish_body, and ngx.req.socket to implement efficient input filters in pure Lua (in the context of rewrite_by_lua* or access_by_lua*), which can be used with other Nginx content handler or upstream modules like ngx_http_proxy_module and ngx_http_fastcgi_module.\nThis function was first introduced in the v0.5.11 release.\nSee also ngx.req.init_body.\nBack to TOC\nngx.req.finish_body syntax: ngx.req.finish_body()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nCompletes the construction process of the new request body created by the ngx.req.init_body and ngx.req.append_body calls.\nThis function can be used with ngx.req.init_body, ngx.req.append_body, and ngx.req.socket to implement efficient input filters in pure Lua (in the context of rewrite_by_lua* or access_by_lua*), which can be used with other Nginx content handler or upstream modules like ngx_http_proxy_module and ngx_http_fastcgi_module.\nThis function was first introduced in the v0.5.11 release.\nSee also ngx.req.init_body.\nBack to TOC\nngx.req.socket syntax: tcpsock, err = ngx.req.socket()\nsyntax: tcpsock, err = ngx.req.socket(raw)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nReturns a read-only cosocket object that wraps the downstream connection. Only receive and receiveuntil methods are supported on this object.\nIn case of error, nil will be returned as well as a string describing the error.\nThe socket object returned by this method is usually used to read the current request\u0026rsquo;s body in a streaming fashion. Do not turn on the lua_need_request_body directive, and do not mix this call with ngx.req.read_body and ngx.req.discard_body.\nIf any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading. Chunked request bodies are not yet supported in this API.\nSince the v0.9.0 release, this function accepts an optional boolean raw argument. When this argument is true, this function returns a full-duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the receive, receiveuntil, and send methods.\nWhen the raw argument is true, it is required that no pending data from any previous ngx.say, ngx.print, or ngx.send_headers calls exists. So if you have these downstream output calls previously, you should call ngx.flush(true) before calling ngx.req.socket(true) to ensure that there is no pending output data. If the request body has not been read yet, then this \u0026ldquo;raw socket\u0026rdquo; can also be used to read the request body.\nYou can use the \u0026ldquo;raw request socket\u0026rdquo; returned by ngx.req.socket(true) to implement fancy protocols like WebSocket, or just emit your own raw HTTP response header or body data. You can refer to the lua-resty-websocket library for a real world example.\nThis function was first introduced in the v0.5.0rc1 release.\nBack to TOC\nngx.exec syntax: ngx.exec(uri, args?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nDoes an internal redirect to uri with args and is similar to the echo_exec directive of the echo-nginx-module.\nngx.exec(\u0026#39;/some-location\u0026#39;); ngx.exec(\u0026#39;/some-location\u0026#39;, \u0026#39;a=3\u0026amp;b=5\u0026amp;c=6\u0026#39;); ngx.exec(\u0026#39;/some-location?a=3\u0026amp;b=5\u0026#39;, \u0026#39;c=6\u0026#39;); The optional second args can be used to specify extra URI query arguments, for example:\nngx.exec(\u0026#34;/foo\u0026#34;, \u0026#34;a=3\u0026amp;b=hello%20world\u0026#34;) Alternatively, a Lua table can be passed for the args argument for ngx_lua to carry out URI escaping and string concatenation.\nngx.exec(\u0026#34;/foo\u0026#34;, { a = 3, b = \u0026#34;hello world\u0026#34; }) The result is exactly the same as the previous example.\nThe format for the Lua table passed as the args argument is identical to the format used in the ngx.encode_args method.\nNamed locations are also supported but the second args argument will be ignored if present and the querystring for the new target is inherited from the referring location (if any).\nGET /foo/file.php?a=hello will return \u0026ldquo;hello\u0026rdquo; and not \u0026ldquo;goodbye\u0026rdquo; in the example below\nlocation /foo { content_by_lua_block { ngx.exec(\u0026#34;@bar\u0026#34;, \u0026#34;a=goodbye\u0026#34;); } } location @bar { content_by_lua_block { local args = ngx.req.get_uri_args() for key, val in pairs(args) do if key == \u0026#34;a\u0026#34; then ngx.say(val) end end } } Note that the ngx.exec method is different from ngx.redirect in that it is purely an internal redirect and that no new external HTTP traffic is involved.\nAlso note that this method call terminates the processing of the current request and that it must be called before ngx.send_headers or explicit response body outputs by either ngx.print or ngx.say.\nIt is recommended that a coding style that combines this method call with the return statement, i.e., return ngx.exec(...) be adopted when this method call is used in contexts other than header_filter_by_lua* to reinforce the fact that the request processing is being terminated.\nBack to TOC\nngx.redirect syntax: ngx.redirect(uri, status?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nIssue an HTTP 301 or 302 redirection to uri.\nThe optional status parameter specifies the HTTP status code to be used. The following status codes are supported right now:\n 301 302 (default) 303 307 308  It is 302 (ngx.HTTP_MOVED_TEMPORARILY) by default.\nHere is an example assuming the current server name is localhost and that it is listening on port 1984:\nreturn ngx.redirect(\u0026#34;/foo\u0026#34;) which is equivalent to\nreturn ngx.redirect(\u0026#34;/foo\u0026#34;, ngx.HTTP_MOVED_TEMPORARILY) Redirecting arbitrary external URLs is also supported, for example:\nreturn ngx.redirect(\u0026#34;http://www.google.com\u0026#34;) We can also use the numerical code directly as the second status argument:\nreturn ngx.redirect(\u0026#34;/foo\u0026#34;, 301) This method is similar to the rewrite directive with the redirect modifier in the standard ngx_http_rewrite_module, for example, this nginx.conf snippet\nrewrite ^ /foo? redirect; # nginx config is equivalent to the following Lua code\nreturn ngx.redirect(\u0026#39;/foo\u0026#39;); -- Lua code while\nrewrite ^ /foo? permanent; # nginx config is equivalent to\nreturn ngx.redirect(\u0026#39;/foo\u0026#39;, ngx.HTTP_MOVED_PERMANENTLY) -- Lua code URI arguments can be specified as well, for example:\nreturn ngx.redirect(\u0026#39;/foo?a=3\u0026amp;b=4\u0026#39;) Note that this method call terminates the processing of the current request and that it must be called before ngx.send_headers or explicit response body outputs by either ngx.print or ngx.say.\nIt is recommended that a coding style that combines this method call with the return statement, i.e., return ngx.redirect(...) be adopted when this method call is used in contexts other than header_filter_by_lua* to reinforce the fact that the request processing is being terminated.\nBack to TOC\nngx.send_headers syntax: ok, err = ngx.send_headers()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nExplicitly send out the response headers.\nSince v0.8.3 this function returns 1 on success, or returns nil and a string describing the error otherwise.\nNote that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out before content is output with ngx.say or ngx.print or when content_by_lua* exits normally.\nBack to TOC\nngx.headers_sent syntax: value = ngx.headers_sent\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nReturns true if the response headers have been sent (by ngx_lua), and false otherwise.\nThis API was first introduced in ngx_lua v0.3.1rc6.\nBack to TOC\nngx.print syntax: ok, err = ngx.print(\u0026hellip;)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nEmits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.\nSince v0.8.3 this function returns 1 on success, or returns nil and a string describing the error otherwise.\nLua nil values will output \u0026quot;nil\u0026quot; strings and Lua boolean values will output \u0026quot;true\u0026quot; and \u0026quot;false\u0026quot; literal strings respectively.\nNested arrays of strings are permitted and the elements in the arrays will be sent one by one:\nlocal table = { \u0026#34;hello, \u0026#34;, {\u0026#34;world: \u0026#34;, true, \u0026#34; or \u0026#34;, false, {\u0026#34;: \u0026#34;, nil}} } ngx.print(table) will yield the output\nhello, world: true or false: nil Non-array table arguments will cause a Lua exception to be thrown.\nThe ngx.null constant will yield the \u0026quot;null\u0026quot; string output.\nThis is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call ngx.flush(true) after calling ngx.print. This can be particularly useful for streaming output. See ngx.flush for more details.\nPlease note that both ngx.print and ngx.say will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.\nBack to TOC\nngx.say syntax: ok, err = ngx.say(\u0026hellip;)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nJust as ngx.print but also emit a trailing newline.\nBack to TOC\nngx.log syntax: ngx.log(log_level, \u0026hellip;)\ncontext: init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nLog arguments concatenated to error.log with the given logging level.\nLua nil arguments are accepted and result in literal \u0026quot;nil\u0026quot; string while Lua booleans result in literal \u0026quot;true\u0026quot; or \u0026quot;false\u0026quot; string outputs. And the ngx.null constant will yield the \u0026quot;null\u0026quot; string output.\nThe log_level argument can take constants like ngx.ERR and ngx.WARN. Check out Nginx log level constants for details.\nThere is a hard coded 2048 byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the NGX_MAX_ERROR_STR macro definition in the src/core/ngx_log.h file in the Nginx source tree.\nBack to TOC\nngx.flush syntax: ok, err = ngx.flush(wait?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nFlushes response output to the client.\nngx.flush accepts an optional boolean wait argument (Default: false) first introduced in the v0.3.1rc34 release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the wait argument set to true switches to synchronous mode.\nIn synchronous mode, the function will not return until all output data has been written into the system send buffer or until the send_timeout setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.\nWhen ngx.flush(true) is called immediately after ngx.print or ngx.say, it causes the latter functions to run in synchronous mode. This can be particularly useful for streaming output.\nNote that ngx.flush is not functional when in the HTTP 1.0 output buffering mode. See HTTP 1.0 support.\nSince v0.8.3 this function returns 1 on success, or returns nil and a string describing the error otherwise.\nBack to TOC\nngx.exit syntax: ngx.exit(status)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nWhen status \u0026gt;= 200 (i.e., ngx.HTTP_OK and above), it will interrupt the execution of the current request and return status code to nginx.\nWhen status == 0 (i.e., ngx.OK), it will only quit the current phase handler (or the content handler if the content_by_lua* directive is used) and continue to run later phases (if any) for the current request.\nThe status argument can be ngx.OK, ngx.ERROR, ngx.HTTP_NOT_FOUND, ngx.HTTP_MOVED_TEMPORARILY, or other HTTP status constants.\nTo return an error page with custom contents, use code snippets like this:\nngx.status = ngx.HTTP_GONE ngx.say(\u0026#34;This is our own content\u0026#34;) -- to cause quit the whole request rather than the current phase handler ngx.exit(ngx.HTTP_OK) The effect in action:\n$ curl -i http://localhost/test HTTP/1.1 410 Gone Server: nginx/1.0.6 Date: Thu, 15 Sep 2011 00:51:48 GMT Content-Type: text/plain Transfer-Encoding: chunked Connection: keep-alive This is our own content Number literals can be used directly as the argument, for instance,\nngx.exit(501) Note that while this method accepts all HTTP status constants as input, it only accepts ngx.OK and ngx.ERROR of the core constants.\nAlso note that this method call terminates the processing of the current request and that it is recommended that a coding style that combines this method call with the return statement, i.e., return ngx.exit(...) be used to reinforce the fact that the request processing is being terminated.\nWhen being used in the contexts of header_filter_by_lua*, balancer_by_lua*, and ssl_session_store_by_lua*, ngx.exit() is an asynchronous operation and will return immediately. This behavior may change in future and it is recommended that users always use return in combination as suggested above.\nBack to TOC\nngx.eof syntax: ok, err = ngx.eof()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nExplicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the \u0026ldquo;last chunk\u0026rdquo;.\nWhen you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on well written HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:\nlocation = /async { keepalive_timeout 0; content_by_lua_block { ngx.say(\u0026#34;got the task!\u0026#34;) ngx.eof() -- well written HTTP clients will close the connection at this point -- access MySQL, PostgreSQL, Redis, Memcached, and etc here... } } But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard ngx_http_proxy_module will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the proxy_ignore_client_abort directive in your location block configured by ngx_http_proxy_module:\nproxy_ignore_client_abort on; A better way to do background jobs is to use the ngx.timer.at API.\nSince v0.8.3 this function returns 1 on success, or returns nil and a string describing the error otherwise.\nBack to TOC\nngx.sleep syntax: ngx.sleep(seconds)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nSleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).\nBehind the scene, this method makes use of the Nginx timers.\nSince the 0.7.20 release, The 0 time argument can also be specified.\nThis method was introduced in the 0.5.0rc30 release.\nBack to TOC\nngx.escape_uri syntax: newstr = ngx.escape_uri(str)\ncontext: init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nEscape str as a URI component.\nBack to TOC\nngx.unescape_uri syntax: newstr = ngx.unescape_uri(str)\ncontext: init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;\nUnescape str as an escaped URI component.\nFor example,\nngx.say(ngx.unescape_uri(\u0026#34;b%20r56+7\u0026#34;)) gives the output\nb r56 7  Back to TOC\nngx.encode_args syntax: str = ngx.encode_args(table)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;\nEncode the Lua table to a query args string according to the URI encoded rules.\nFor example,\nngx.encode_args({foo = 3, [\u0026#34;b r\u0026#34;] = \u0026#34;hello world\u0026#34;}) yields\nfoo=3\u0026amp;b%20r=hello%20world  The table keys must be Lua strings.\nMulti-value query args are also supported. Just use a Lua table for the argument\u0026rsquo;s value, for example:\nngx.encode_args({baz = {32, \u0026#34;hello\u0026#34;}}) gives\nbaz=32\u0026amp;baz=hello  If the value table is empty and the effect is equivalent to the nil value.\nBoolean argument values are also supported, for instance,\nngx.encode_args({a = true, b = 1}) yields\na\u0026amp;b=1  If the argument value is false, then the effect is equivalent to the nil value.\nThis method was first introduced in the v0.3.1rc27 release.\nBack to TOC\nngx.decode_args syntax: table, err = ngx.decode_args(str, max_args?)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nDecodes a URI encoded query-string into a Lua table. This is the inverse function of ngx.encode_args.\nThe optional max_args argument can be used to specify the maximum number of arguments parsed from the str argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks. Since v0.10.13, when the limit is exceeded, it will return a second value which is the string \u0026quot;truncated\u0026quot;.\nThis argument can be set to zero to remove the limit and to process all request arguments received:\nlocal args = ngx.decode_args(str, 0) Removing the max_args cap is strongly discouraged.\nThis method was introduced in the v0.5.0rc29.\nBack to TOC\nngx.encode_base64 syntax: newstr = ngx.encode_base64(str, no_padding?)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nEncodes str to a base64 digest.\nSince the 0.9.16 release, an optional boolean-typed no_padding argument can be specified to control whether the base64 padding should be appended to the resulting digest (default to false, i.e., with padding enabled).\nBack to TOC\nngx.decode_base64 syntax: newstr = ngx.decode_base64(str)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nDecodes the str argument as a base64 digest to the raw form. Returns nil if str is not well formed.\nBack to TOC\nngx.crc32_short syntax: intval = ngx.crc32_short(str)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nCalculates the CRC-32 (Cyclic Redundancy Code) digest for the str argument.\nThis method performs better on relatively short str inputs (i.e., less than 30 ~ 60 bytes), as compared to ngx.crc32_long. The result is exactly the same as ngx.crc32_long.\nBehind the scene, it is just a thin wrapper around the ngx_crc32_short function defined in the Nginx core.\nThis API was first introduced in the v0.3.1rc8 release.\nBack to TOC\nngx.crc32_long syntax: intval = ngx.crc32_long(str)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nCalculates the CRC-32 (Cyclic Redundancy Code) digest for the str argument.\nThis method performs better on relatively long str inputs (i.e., longer than 30 ~ 60 bytes), as compared to ngx.crc32_short. The result is exactly the same as ngx.crc32_short.\nBehind the scene, it is just a thin wrapper around the ngx_crc32_long function defined in the Nginx core.\nThis API was first introduced in the v0.3.1rc8 release.\nBack to TOC\nngx.hmac_sha1 syntax: digest = ngx.hmac_sha1(secret_key, str)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nComputes the HMAC-SHA1 digest of the argument str and turns the result using the secret key \u0026lt;secret_key\u0026gt;.\nThe raw binary form of the HMAC-SHA1 digest will be generated, use ngx.encode_base64, for example, to encode the result to a textual representation if desired.\nFor example,\nlocal key = \u0026#34;thisisverysecretstuff\u0026#34; local src = \u0026#34;some string we want to sign\u0026#34; local digest = ngx.hmac_sha1(key, src) ngx.say(ngx.encode_base64(digest)) yields the output\nR/pvxzHC4NLtj7S+kXFg/NePTmk=  This API requires the OpenSSL library enabled in the Nginx build (usually by passing the --with-http_ssl_module option to the ./configure script).\nThis function was first introduced in the v0.3.1rc29 release.\nBack to TOC\nngx.md5 syntax: digest = ngx.md5(str)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the hexadecimal representation of the MD5 digest of the str argument.\nFor example,\nlocation = /md5 { content_by_lua_block { ngx.say(ngx.md5(\u0026#34;hello\u0026#34;)) } } yields the output\n5d41402abc4b2a76b9719d911017c592  See ngx.md5_bin if the raw binary MD5 digest is required.\nBack to TOC\nngx.md5_bin syntax: digest = ngx.md5_bin(str)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the binary form of the MD5 digest of the str argument.\nSee ngx.md5 if the hexadecimal form of the MD5 digest is required.\nBack to TOC\nngx.sha1_bin syntax: digest = ngx.sha1_bin(str)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the binary form of the SHA-1 digest of the str argument.\nThis function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).\nThis function was first introduced in the v0.5.0rc6.\nBack to TOC\nngx.quote_sql_str syntax: quoted_value = ngx.quote_sql_str(raw_value)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns a quoted SQL string literal according to the MySQL quoting rules.\nBack to TOC\nngx.today syntax: str = ngx.today()\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns current date (in the format yyyy-mm-dd) from the nginx cached time (no syscall involved unlike Lua\u0026rsquo;s date library).\nThis is the local time.\nBack to TOC\nngx.time syntax: secs = ngx.time()\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua\u0026rsquo;s date library).\nUpdates of the Nginx time cache can be forced by calling ngx.update_time first.\nBack to TOC\nngx.now syntax: secs = ngx.now()\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua\u0026rsquo;s date library).\nYou can forcibly update the Nginx time cache by calling ngx.update_time first.\nThis API was first introduced in v0.3.1rc32.\nBack to TOC\nngx.update_time syntax: ngx.update_time()\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nForcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.\nThis API was first introduced in v0.3.1rc32.\nBack to TOC\nngx.localtime syntax: str = ngx.localtime()\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the current time stamp (in the format yyyy-mm-dd hh:mm:ss) of the nginx cached time (no syscall involved unlike Lua\u0026rsquo;s os.date function).\nThis is the local time.\nBack to TOC\nngx.utctime syntax: str = ngx.utctime()\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the current time stamp (in the format yyyy-mm-dd hh:mm:ss) of the nginx cached time (no syscall involved unlike Lua\u0026rsquo;s os.date function).\nThis is the UTC time.\nBack to TOC\nngx.cookie_time syntax: str = ngx.cookie_time(sec)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns a formatted string can be used as the cookie expiration time. The parameter sec is the time stamp in seconds (like those returned from ngx.time).\nngx.say(ngx.cookie_time(1290079655)) -- yields \u0026#34;Thu, 18-Nov-10 11:27:35 GMT\u0026#34; Back to TOC\nngx.http_time syntax: str = ngx.http_time(sec)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns a formated string can be used as the http header time (for example, being used in Last-Modified header). The parameter sec is the time stamp in seconds (like those returned from ngx.time).\nngx.say(ngx.http_time(1290079655)) -- yields \u0026#34;Thu, 18 Nov 2010 11:27:35 GMT\u0026#34; Back to TOC\nngx.parse_http_time syntax: sec = ngx.parse_http_time(str)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nParse the http time string (as returned by ngx.http_time) into seconds. Returns the seconds or nil if the input string is in bad forms.\nlocal time = ngx.parse_http_time(\u0026#34;Thu, 18 Nov 2010 11:27:35 GMT\u0026#34;) if time == nil then ... end Back to TOC\nngx.is_subrequest syntax: value = ngx.is_subrequest\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;\nReturns true if the current request is an nginx subrequest, or false otherwise.\nBack to TOC\nngx.re.match syntax: captures, err = ngx.re.match(subject, regex, options?, ctx?, res_table?)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nMatches the subject string using the Perl compatible regular expression regex with the optional options.\nOnly the first occurrence of the match is returned, or nil if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, nil and a string describing the error will be returned.\nWhen a match is found, a Lua table captures is returned, where captures[0] holds the whole substring being matched, and captures[1] holds the first parenthesized sub-pattern\u0026rsquo;s capturing, captures[2] the second, and so on.\nlocal m, err = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, \u0026#34;[0-9]+\u0026#34;) if m then -- m[0] == \u0026#34;1234\u0026#34; else if err then ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return end ngx.say(\u0026#34;match not found\u0026#34;) endlocal m, err = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, \u0026#34;([0-9])[0-9]+\u0026#34;) -- m[0] == \u0026#34;1234\u0026#34; -- m[1] == \u0026#34;1\u0026#34; Named captures are also supported since the v0.7.14 release and are returned in the same Lua table as key-value pairs as the numbered captures.\nlocal m, err = ngx.re.match(\u0026#34;hello, 1234\u0026#34;, \u0026#34;([0-9])(?\u0026lt;remaining\u0026gt;[0-9]+)\u0026#34;) -- m[0] == \u0026#34;1234\u0026#34; -- m[1] == \u0026#34;1\u0026#34; -- m[2] == \u0026#34;234\u0026#34; -- m[\u0026#34;remaining\u0026#34;] == \u0026#34;234\u0026#34; Unmatched subpatterns will have false values in their captures table fields.\nlocal m, err = ngx.re.match(\u0026#34;hello, world\u0026#34;, \u0026#34;(world)|(hello)|(?\u0026lt;named\u0026gt;howdy)\u0026#34;) -- m[0] == \u0026#34;hello\u0026#34; -- m[1] == false -- m[2] == \u0026#34;hello\u0026#34; -- m[3] == false -- m[\u0026#34;named\u0026#34;] == false Specify options to control how the match operation will be performed. The following option characters are supported:\na anchored mode (only match from the beginning) d enable the DFA mode (or the longest token match semantics). this requires PCRE 6.0+ or else a Lua exception will be thrown. first introduced in ngx_lua v0.3.1rc30. D enable duplicate named pattern support. This allows named subpattern names to be repeated, returning the captures in an array-like Lua table. for example, local m = ngx.re.match(\u0026quot;hello, world\u0026quot;, \u0026quot;(?\u0026lt;named\u0026gt;\\w+), (?\u0026lt;named\u0026gt;\\w+)\u0026quot;, \u0026quot;D\u0026quot;) -- m[\u0026quot;named\u0026quot;] == {\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;} this option was first introduced in the v0.7.14 release. this option requires at least PCRE 8.12. i case insensitive mode (similar to Perl's /i modifier) j enable PCRE JIT compilation, this requires PCRE 8.21+ which must be built with the --enable-jit option. for optimum performance, this option should always be used together with the 'o' option. first introduced in ngx_lua v0.3.1rc30. J enable the PCRE Javascript compatible mode. this option was first introduced in the v0.7.14 release. this option requires at least PCRE 8.12. m multi-line mode (similar to Perl's /m modifier) o compile-once mode (similar to Perl's /o modifier), to enable the worker-process-level compiled-regex cache s single-line mode (similar to Perl's /s modifier) u UTF-8 mode. this requires PCRE to be built with the --enable-utf8 option or else a Lua exception will be thrown. U similar to \u0026quot;u\u0026quot; but disables PCRE's UTF-8 validity check on the subject string. first introduced in ngx_lua v0.8.1. x extended mode (similar to Perl's /x modifier)  These options can be combined:\nlocal m, err = ngx.re.match(\u0026#34;hello, world\u0026#34;, \u0026#34;HEL LO\u0026#34;, \u0026#34;ix\u0026#34;) -- m[0] == \u0026#34;hello\u0026#34;local m, err = ngx.re.match(\u0026#34;hello, 美好生活\u0026#34;, \u0026#34;HELLO, (.{2})\u0026#34;, \u0026#34;iu\u0026#34;) -- m[0] == \u0026#34;hello, 美好\u0026#34; -- m[1] == \u0026#34;美好\u0026#34; The o option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the lua_regex_cache_max_entries directive.\nThe optional fourth argument, ctx, can be a Lua table holding an optional pos field. When the pos field in the ctx table argument is specified, ngx.re.match will start matching from that offset (starting from 1). Regardless of the presence of the pos field in the ctx table, ngx.re.match will always set this pos field to the position after the substring matched by the whole pattern in case of a successful match. When match fails, the ctx table will be left intact.\nlocal ctx = {} local m, err = ngx.re.match(\u0026#34;1234, hello\u0026#34;, \u0026#34;[0-9]+\u0026#34;, \u0026#34;\u0026#34;, ctx) -- m[0] = \u0026#34;1234\u0026#34; -- ctx.pos == 5local ctx = { pos = 2 } local m, err = ngx.re.match(\u0026#34;1234, hello\u0026#34;, \u0026#34;[0-9]+\u0026#34;, \u0026#34;\u0026#34;, ctx) -- m[0] = \u0026#34;234\u0026#34; -- ctx.pos == 5 The ctx table argument combined with the a regex modifier can be used to construct a lexer atop ngx.re.match.\nNote that, the options argument is not optional when the ctx argument is specified and that the empty Lua string (\u0026quot;\u0026quot;) must be used as placeholder for options if no meaningful regex options are required.\nThis method requires the PCRE library enabled in Nginx. (Known Issue With Special Escaping Sequences).\nTo confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the --with-debug option to Nginx or OpenResty\u0026rsquo;s ./configure script. Then, enable the \u0026ldquo;debug\u0026rdquo; error log level in error_log directive. The following message will be generated if PCRE JIT is enabled:\npcre JIT compiling result: 1  Starting from the 0.9.4 release, this function also accepts a 5th argument, res_table, for letting the caller supply the Lua table used to hold all the capturing results. Starting from 0.9.6, it is the caller\u0026rsquo;s responsibility to ensure this table is empty. This is very useful for recycling Lua tables and saving GC and table allocation overhead.\nThis feature was introduced in the v0.2.1rc11 release.\nBack to TOC\nngx.re.find syntax: from, to, err = ngx.re.find(subject, regex, options?, ctx?, nth?)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSimilar to ngx.re.match but only returns the beginning index (from) and end index (to) of the matched substring. The returned indexes are 1-based and can be fed directly into the string.sub API function to obtain the matched substring.\nIn case of errors (like bad regexes or any PCRE runtime errors), this API function returns two nil values followed by a string describing the error.\nIf no match is found, this function just returns a nil value.\nBelow is an example:\nlocal s = \u0026#34;hello, 1234\u0026#34; local from, to, err = ngx.re.find(s, \u0026#34;([0-9]+)\u0026#34;, \u0026#34;jo\u0026#34;) if from then ngx.say(\u0026#34;from: \u0026#34;, from) ngx.say(\u0026#34;to: \u0026#34;, to) ngx.say(\u0026#34;matched: \u0026#34;, string.sub(s, from, to)) else if err then ngx.say(\u0026#34;error: \u0026#34;, err) return end ngx.say(\u0026#34;not matched!\u0026#34;) end This example produces the output\nfrom: 8 to: 11 matched: 1234  Because this API function does not create new Lua strings nor new Lua tables, it is much faster than ngx.re.match. It should be used wherever possible.\nSince the 0.9.3 release, an optional 5th argument, nth, is supported to specify which (submatch) capture\u0026rsquo;s indexes to return. When nth is 0 (which is the default), the indexes for the whole matched substring is returned; when nth is 1, then the 1st submatch capture\u0026rsquo;s indexes are returned; when nth is 2, then the 2nd submatch capture is returned, and so on. When the specified submatch does not have a match, then two nil values will be returned. Below is an example for this:\nlocal str = \u0026#34;hello, 1234\u0026#34; local from, to = ngx.re.find(str, \u0026#34;([0-9])([0-9]+)\u0026#34;, \u0026#34;jo\u0026#34;, nil, 2) if from then ngx.say(\u0026#34;matched 2nd submatch: \u0026#34;, string.sub(str, from, to)) -- yields \u0026#34;234\u0026#34; end This API function was first introduced in the v0.9.2 release.\nBack to TOC\nngx.re.gmatch syntax: iterator, err = ngx.re.gmatch(subject, regex, options?)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSimilar to ngx.re.match, but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the \u0026lt;subject\u0026gt; string argument with the PCRE regex.\nIn case of errors, like seeing an ill-formed regular expression, nil and a string describing the error will be returned.\nHere is a small example to demonstrate its basic usage:\nlocal iterator, err = ngx.re.gmatch(\u0026#34;hello, world!\u0026#34;, \u0026#34;([a-z]+)\u0026#34;, \u0026#34;i\u0026#34;) if not iterator then ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return end local m m, err = iterator() -- m[0] == m[1] == \u0026#34;hello\u0026#34; if err then ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return end m, err = iterator() -- m[0] == m[1] == \u0026#34;world\u0026#34; if err then ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return end m, err = iterator() -- m == nil if err then ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return end More often we just put it into a Lua loop:\nlocal it, err = ngx.re.gmatch(\u0026#34;hello, world!\u0026#34;, \u0026#34;([a-z]+)\u0026#34;, \u0026#34;i\u0026#34;) if not it then ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return end while true do local m, err = it() if err then ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return end if not m then -- no match found (any more) break end -- found a match ngx.say(m[0]) ngx.say(m[1]) end The optional options argument takes exactly the same semantics as the ngx.re.match method.\nThe current implementation requires that the iterator returned should only be used in a single request. That is, one should not assign it to a variable belonging to persistent namespace like a Lua package.\nThis method requires the PCRE library enabled in Nginx. (Known Issue With Special Escaping Sequences).\nThis feature was first introduced in the v0.2.1rc12 release.\nBack to TOC\nngx.re.sub syntax: newstr, n, err = ngx.re.sub(subject, regex, replace, options?)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSubstitutes the first match of the Perl compatible regular expression regex on the subject argument string with the string or function argument replace. The optional options argument has exactly the same meaning as in ngx.re.match.\nThis method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the \u0026lt;replace\u0026gt; string argument, it will return nil and a string describing the error.\nWhen the replace is a string, then it is treated as a special template for string replacement. For example,\nlocal newstr, n, err = ngx.re.sub(\u0026#34;hello, 1234\u0026#34;, \u0026#34;([0-9])[0-9]\u0026#34;, \u0026#34;[$0][$1]\u0026#34;) if newstr then -- newstr == \u0026#34;hello, [12][1]34\u0026#34; -- n == 1 else ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return end where $0 referring to the whole substring matched by the pattern and $1 referring to the first parenthesized capturing substring.\nCurly braces can also be used to disambiguate variable names from the background string literals:\nlocal newstr, n, err = ngx.re.sub(\u0026#34;hello, 1234\u0026#34;, \u0026#34;[0-9]\u0026#34;, \u0026#34;${0}00\u0026#34;) -- newstr == \u0026#34;hello, 100234\u0026#34; -- n == 1 Literal dollar sign characters ($) in the replace string argument can be escaped by another dollar sign, for instance,\nlocal newstr, n, err = ngx.re.sub(\u0026#34;hello, 1234\u0026#34;, \u0026#34;[0-9]\u0026#34;, \u0026#34;$$\u0026#34;) -- newstr == \u0026#34;hello, $234\u0026#34; -- n == 1 Do not use backlashes to escape dollar signs; it will not work as expected.\nWhen the replace argument is of type \u0026ldquo;function\u0026rdquo;, then it will be invoked with the \u0026ldquo;match table\u0026rdquo; as the argument to generate the replace string literal for substitution. The \u0026ldquo;match table\u0026rdquo; fed into the replace function is exactly the same as the return value of ngx.re.match. Here is an example:\nlocal func = function (m) return \u0026#34;[\u0026#34; .. m[0] .. \u0026#34;][\u0026#34; .. m[1] .. \u0026#34;]\u0026#34; end local newstr, n, err = ngx.re.sub(\u0026#34;hello, 1234\u0026#34;, \u0026#34;( [0-9] ) [0-9]\u0026#34;, func, \u0026#34;x\u0026#34;) -- newstr == \u0026#34;hello, [12][1]34\u0026#34; -- n == 1 The dollar sign characters in the return value of the replace function argument are not special at all.\nThis method requires the PCRE library enabled in Nginx. (Known Issue With Special Escaping Sequences).\nThis feature was first introduced in the v0.2.1rc13 release.\nBack to TOC\nngx.re.gsub syntax: newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nJust like ngx.re.sub, but does global substitution.\nHere is some examples:\nlocal newstr, n, err = ngx.re.gsub(\u0026#34;hello, world\u0026#34;, \u0026#34;([a-z])[a-z]+\u0026#34;, \u0026#34;[$0,$1]\u0026#34;, \u0026#34;i\u0026#34;) if newstr then -- newstr == \u0026#34;[hello,h], [world,w]\u0026#34; -- n == 2 else ngx.log(ngx.ERR, \u0026#34;error: \u0026#34;, err) return endlocal func = function (m) return \u0026#34;[\u0026#34; .. m[0] .. \u0026#34;,\u0026#34; .. m[1] .. \u0026#34;]\u0026#34; end local newstr, n, err = ngx.re.gsub(\u0026#34;hello, world\u0026#34;, \u0026#34;([a-z])[a-z]+\u0026#34;, func, \u0026#34;i\u0026#34;) -- newstr == \u0026#34;[hello,h], [world,w]\u0026#34; -- n == 2 This method requires the PCRE library enabled in Nginx. (Known Issue With Special Escaping Sequences).\nThis feature was first introduced in the v0.2.1rc15 release.\nBack to TOC\nngx.shared.DICT syntax: dict = ngx.shared.DICT\nsyntax: dict = ngx.shared[name_var]\ncontext: init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nFetching the shm-based Lua dictionary object for the shared memory zone named DICT defined by the lua_shared_dict directive.\nShared memory zones are always shared by all the nginx worker processes in the current nginx server instance.\nThe resulting object dict has the following methods:\n get get_stale set safe_set add safe_add replace delete incr lpush rpush lpop rpop llen ttl expire flush_all flush_expired get_keys capacity free_space  All these methods are atomic operations, that is, safe from concurrent accesses from multiple nginx worker processes for the same lua_shared_dict zone.\nHere is an example:\nhttp { lua_shared_dict dogs 10m; server { location /set { content_by_lua_block { local dogs = ngx.shared.dogs dogs:set(\u0026#34;Jim\u0026#34;, 8) ngx.say(\u0026#34;STORED\u0026#34;) } } location /get { content_by_lua_block { local dogs = ngx.shared.dogs ngx.say(dogs:get(\u0026#34;Jim\u0026#34;)) } } } } Let us test it:\n$ curl localhost/set STORED $ curl localhost/get 8 $ curl localhost/get 8 The number 8 will be consistently output when accessing /get regardless of how many Nginx workers there are because the dogs dictionary resides in the shared memory and visible to all of the worker processes.\nThe shared dictionary will retain its contents through a server config reload (either by sending the HUP signal to the Nginx process or by using the -s reload command-line option).\nThe contents in the dictionary storage will be lost, however, when the Nginx server quits.\nThis feature was first introduced in the v0.3.1rc22 release.\nBack to TOC\nngx.shared.DICT.get syntax: value, flags = ngx.shared.DICT:get(key)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nRetrieving the value in the dictionary ngx.shared.DICT for the key key. If the key does not exist or has expired, then nil will be returned.\nIn case of errors, nil and a string describing the error will be returned.\nThe value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.\nThe first argument to this method must be the dictionary object itself, for example,\nlocal cats = ngx.shared.cats local value, flags = cats.get(cats, \u0026#34;Marry\u0026#34;) or use Lua\u0026rsquo;s syntactic sugar for method calls:\nlocal cats = ngx.shared.cats local value, flags = cats:get(\u0026#34;Marry\u0026#34;) These two forms are fundamentally equivalent.\nIf the user flags is 0 (the default), then no flags value will be returned.\nThis feature was first introduced in the v0.3.1rc22 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.get_stale syntax: value, flags, stale = ngx.shared.DICT:get_stale(key)\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSimilar to the get method but returns the value even if the key has already expired.\nReturns a 3rd value, stale, indicating whether the key has expired or not.\nNote that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.\nThis method was first introduced in the 0.8.6 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.set syntax: success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nUnconditionally sets a key-value pair into the shm-based dictionary ngx.shared.DICT. Returns three values:\n success: boolean value to indicate whether the key-value pair is stored or not. err: textual error message, can be \u0026quot;no memory\u0026quot;. forcible: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.  The value argument inserted can be Lua booleans, numbers, strings, or nil. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the get method.\nThe optional exptime argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is 0.001 seconds. If the exptime takes the value 0 (which is the default), then the item will never expire.\nThe optional flags argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to 0. The user flags argument was first introduced in the v0.5.0rc2 release.\nWhen it fails to allocate memory for the current key-value item, then set will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by lua_shared_dict or memory segmentation), then the err return value will be no memory and success will be false.\nIf this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the forcible return value will be true. If it stores the item without forcibly removing other valid items, then the return value forcible will be false.\nThe first argument to this method must be the dictionary object itself, for example,\nlocal cats = ngx.shared.cats local succ, err, forcible = cats.set(cats, \u0026#34;Marry\u0026#34;, \u0026#34;it is a nice cat!\u0026#34;) or use Lua\u0026rsquo;s syntactic sugar for method calls:\nlocal cats = ngx.shared.cats local succ, err, forcible = cats:set(\u0026#34;Marry\u0026#34;, \u0026#34;it is a nice cat!\u0026#34;) These two forms are fundamentally equivalent.\nThis feature was first introduced in the v0.3.1rc22 release.\nPlease note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.safe_set syntax: ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSimilar to the set method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return nil and the string \u0026ldquo;no memory\u0026rdquo;.\nThis feature was first introduced in the v0.7.18 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.add syntax: success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nJust like the set method, but only stores the key-value pair into the dictionary ngx.shared.DICT if the key does not exist.\nIf the key argument already exists in the dictionary (and not expired for sure), the success return value will be false and the err return value will be \u0026quot;exists\u0026quot;.\nThis feature was first introduced in the v0.3.1rc22 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.safe_add syntax: ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSimilar to the add method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return nil and the string \u0026ldquo;no memory\u0026rdquo;.\nThis feature was first introduced in the v0.7.18 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.replace syntax: success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nJust like the set method, but only stores the key-value pair into the dictionary ngx.shared.DICT if the key does exist.\nIf the key argument does not exist in the dictionary (or expired already), the success return value will be false and the err return value will be \u0026quot;not found\u0026quot;.\nThis feature was first introduced in the v0.3.1rc22 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.delete syntax: ngx.shared.DICT:delete(key)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nUnconditionally removes the key-value pair from the shm-based dictionary ngx.shared.DICT.\nIt is equivalent to ngx.shared.DICT:set(key, nil).\nThis feature was first introduced in the v0.3.1rc22 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.incr syntax: newval, err, forcible? = ngx.shared.DICT:incr(key, value, init?, init_ttl?)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\noptional requirement: resty.core.shdict or resty.core\nIncrements the (numerical) value for key in the shm-based dictionary ngx.shared.DICT by the step value value. Returns the new resulting number if the operation is successfully completed or nil and an error message otherwise.\nWhen the key does not exist or has already expired in the shared dictionary,\n if the init argument is not specified or takes the value nil, this method will return nil and the error string \u0026quot;not found\u0026quot;, or if the init argument takes a number value, this method will create a new key with the value init + value.  Like the add method, it also overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone.\nThe optional init_ttl argument specifies expiration time (in seconds) of the value when it is initialized via the init argument. The time resolution is 0.001 seconds. If init_ttl takes the value 0 (which is the default), then the item will never expire. This argument cannot be provided without providing the init argument as well, and has no effect if the value already exists (e.g., if it was previously inserted via set or the likes).\nNote: Usage of the init_ttl argument requires the resty.core.shdict or resty.core modules from the lua-resty-core library. Example:\nrequire \u0026#34;resty.core\u0026#34; local cats = ngx.shared.cats local newval, err = cats:incr(\u0026#34;black_cats\u0026#34;, 1, 0, 0.1) print(newval) -- 1 ngx.sleep(0.2) local val, err = cats:get(\u0026#34;black_cats\u0026#34;) print(val) -- nil The forcible return value will always be nil when the init argument is not specified.\nIf this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the forcible return value will be true. If it stores the item without forcibly removing other valid items, then the return value forcible will be false.\nIf the original value is not a valid Lua number in the dictionary, it will return nil and \u0026quot;not a number\u0026quot;.\nThe value argument and init argument can be any valid Lua numbers, like negative numbers or floating-point numbers.\nThis method was first introduced in the v0.3.1rc22 release.\nThe optional init parameter was first added in the v0.10.6 release.\nThe optional init_ttl parameter was introduced in the v0.10.12rc2 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.lpush syntax: length, err = ngx.shared.DICT:lpush(key, value)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nInserts the specified (numerical or string) value at the head of the list named key in the shm-based dictionary ngx.shared.DICT. Returns the number of elements in the list after the push operation.\nIf key does not exist, it is created as an empty list before performing the push operation. When the key already takes a value that is not a list, it will return nil and \u0026quot;value not a list\u0026quot;.\nIt never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return nil and the string \u0026ldquo;no memory\u0026rdquo;.\nThis feature was first introduced in the v0.10.6 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.rpush syntax: length, err = ngx.shared.DICT:rpush(key, value)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSimilar to the lpush method, but inserts the specified (numerical or string) value at the tail of the list named key.\nThis feature was first introduced in the v0.10.6 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.lpop syntax: val, err = ngx.shared.DICT:lpop(key)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nRemoves and returns the first element of the list named key in the shm-based dictionary ngx.shared.DICT.\nIf key does not exist, it will return nil. When the key already takes a value that is not a list, it will return nil and \u0026quot;value not a list\u0026quot;.\nThis feature was first introduced in the v0.10.6 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.rpop syntax: val, err = ngx.shared.DICT:rpop(key)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nRemoves and returns the last element of the list named key in the shm-based dictionary ngx.shared.DICT.\nIf key does not exist, it will return nil. When the key already takes a value that is not a list, it will return nil and \u0026quot;value not a list\u0026quot;.\nThis feature was first introduced in the v0.10.6 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.llen syntax: len, err = ngx.shared.DICT:llen(key)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the number of elements in the list named key in the shm-based dictionary ngx.shared.DICT.\nIf key does not exist, it is interpreted as an empty list and 0 is returned. When the key already takes a value that is not a list, it will return nil and \u0026quot;value not a list\u0026quot;.\nThis feature was first introduced in the v0.10.6 release.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.ttl syntax: ttl, err = ngx.shared.DICT:ttl(key)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nrequires: resty.core.shdict or resty.core\nRetrieves the remaining TTL (time-to-live in seconds) of a key-value pair in the shm-based dictionary ngx.shared.DICT. Returns the TTL as a number if the operation is successfully completed or nil and an error message otherwise.\nIf the key does not exist (or has already expired), this method will return nil and the error string \u0026quot;not found\u0026quot;.\nThe TTL is originally determined by the exptime argument of the set, add, replace (and the likes) methods. It has a time resolution of 0.001 seconds. A value of 0 means that the item will never expire.\nExample:\nrequire \u0026#34;resty.core\u0026#34; local cats = ngx.shared.cats local succ, err = cats:set(\u0026#34;Marry\u0026#34;, \u0026#34;a nice cat\u0026#34;, 0.5) ngx.sleep(0.2) local ttl, err = cats:ttl(\u0026#34;Marry\u0026#34;) ngx.say(ttl) -- 0.3 This feature was first introduced in the v0.10.11 release.\nNote: This method requires the resty.core.shdict or resty.core modules from the lua-resty-core library.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.expire syntax: success, err = ngx.shared.DICT:expire(key, exptime)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nrequires: resty.core.shdict or resty.core\nUpdates the exptime (in second) of a key-value pair in the shm-based dictionary ngx.shared.DICT. Returns a boolean indicating success if the operation completes or nil and an error message otherwise.\nIf the key does not exist, this method will return nil and the error string \u0026quot;not found\u0026quot;.\nThe exptime argument has a resolution of 0.001 seconds. If exptime is 0, then the item will never expire.\nExample:\nrequire \u0026#34;resty.core\u0026#34; local cats = ngx.shared.cats local succ, err = cats:set(\u0026#34;Marry\u0026#34;, \u0026#34;a nice cat\u0026#34;, 0.1) succ, err = cats:expire(\u0026#34;Marry\u0026#34;, 0.5) ngx.sleep(0.2) local val, err = cats:get(\u0026#34;Marry\u0026#34;) ngx.say(val) -- \u0026#34;a nice cat\u0026#34; This feature was first introduced in the v0.10.11 release.\nNote: This method requires the resty.core.shdict or resty.core modules from the lua-resty-core library.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.flush_all syntax: ngx.shared.DICT:flush_all()\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nFlushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.\nThis feature was first introduced in the v0.5.0rc17 release.\nSee also ngx.shared.DICT.flush_expired and ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.flush_expired syntax: flushed = ngx.shared.DICT:flush_expired(max_count?)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nFlushes out the expired items in the dictionary, up to the maximal number specified by the optional max_count argument. When the max_count argument is given 0 or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.\nUnlike the flush_all method, this method actually frees up the memory used by the expired items.\nThis feature was first introduced in the v0.6.3 release.\nSee also ngx.shared.DICT.flush_all and ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.get_keys syntax: keys = ngx.shared.DICT:get_keys(max_count?)\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nFetch a list of the keys from the dictionary, up to \u0026lt;max_count\u0026gt;.\nBy default, only the first 1024 keys (if any) are returned. When the \u0026lt;max_count\u0026gt; argument is given the value 0, then all the keys will be returned even there is more than 1024 keys in the dictionary.\nCAUTION Avoid calling this method on dictionaries with a very large number of keys as it may lock the dictionary for significant amount of time and block Nginx worker processes trying to access the dictionary.\nThis feature was first introduced in the v0.7.3 release.\nBack to TOC\nngx.shared.DICT.capacity syntax: capacity_bytes = ngx.shared.DICT:capacity()\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nrequires: resty.core.shdict or resty.core\nRetrieves the capacity in bytes for the shm-based dictionary ngx.shared.DICT declared with the lua_shared_dict directive.\nExample:\nrequire \u0026#34;resty.core.shdict\u0026#34; local cats = ngx.shared.cats local capacity_bytes = cats:capacity() This feature was first introduced in the v0.10.11 release.\nNote: This method requires the resty.core.shdict or resty.core modules from the lua-resty-core library.\nThis feature requires at least nginx core version 0.7.3.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.shared.DICT.free_space syntax: free_page_bytes = ngx.shared.DICT:free_space()\ncontext: init_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nrequires: resty.core.shdict or resty.core\nRetrieves the free page size in bytes for the shm-based dictionary ngx.shared.DICT.\nNote: The memory for ngx.shared.DICT is allocated via the nginx slab allocator which has each slot for data size ranges like ~8, 9~16, 17~32, \u0026hellip;, 1025~2048, 2048~ bytes. And pages are assigned to a slot if there is no room in already assigned pages for the slot.\nSo even if the return value of the free_space method is zero, there may be room in already assigned pages, so you may successfully set a new key value pair to the shared dict without getting true for forcible or non nil err from the ngx.shared.DICT.set.\nOn the other hand, if already assigned pages for a slot are full and a new key value pair is added to the slot and there is no free page, you may get true for forcible or non nil err from the ngx.shared.DICT.set method.\nExample:\nrequire \u0026#34;resty.core.shdict\u0026#34; local cats = ngx.shared.cats local free_page_bytes = cats:free_space() This feature was first introduced in the v0.10.11 release.\nNote: This method requires the resty.core.shdict or resty.core modules from the lua-resty-core library.\nThis feature requires at least nginx core version 1.11.7.\nSee also ngx.shared.DICT.\nBack to TOC\nngx.socket.udp syntax: udpsock = ngx.socket.udp()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nCreates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the \u0026ldquo;cosocket\u0026rdquo; objects). The following methods are supported on this object:\n setpeername send receive close settimeout  It is intended to be compatible with the UDP API of the LuaSocket library but is 100% nonblocking out of the box.\nThis feature was first introduced in the v0.5.7 release.\nSee also ngx.socket.tcp.\nBack to TOC\nudpsock:setpeername syntax: ok, err = udpsock:setpeername(host, port)\nsyntax: ok, err = udpsock:setpeername(\u0026ldquo;unix:/path/to/unix-domain.socket\u0026rdquo;)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nAttempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a \u0026ldquo;connection\u0026rdquo;, but only just set the name of the remote peer for subsequent read/write operations.\nBoth IP addresses and domain names can be specified as the host argument. In case of domain names, this method will use Nginx core\u0026rsquo;s dynamic resolver to parse the domain name without blocking and it is required to configure the resolver directive in the nginx.conf file like this:\nresolver 8.8.8.8; # use Google\u0026#39;s public DNS nameserver If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.\nIn case of error, the method returns nil followed by a string describing the error. In case of success, the method returns 1.\nHere is an example for connecting to a UDP (memcached) server:\nlocation /test { resolver 8.8.8.8; content_by_lua_block { local sock = ngx.socket.udp() local ok, err = sock:setpeername(\u0026#34;my.memcached.server.domain\u0026#34;, 11211) if not ok then ngx.say(\u0026#34;failed to connect to memcached: \u0026#34;, err) return end ngx.say(\u0026#34;successfully connected to memcached!\u0026#34;) sock:close() } } Since the v0.7.18 release, connecting to a datagram unix domain socket file is also possible on Linux:\nlocal sock = ngx.socket.udp() local ok, err = sock:setpeername(\u0026#34;unix:/tmp/some-datagram-service.sock\u0026#34;) if not ok then ngx.say(\u0026#34;failed to connect to the datagram unix domain socket: \u0026#34;, err) return end assuming the datagram service is listening on the unix domain socket file /tmp/some-datagram-service.sock and the client socket will use the \u0026ldquo;autobind\u0026rdquo; feature on Linux.\nCalling this method on an already connected socket object will cause the original connection to be closed first.\nThis method was first introduced in the v0.5.7 release.\nBack to TOC\nudpsock:send syntax: ok, err = udpsock:send(data)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nSends data on the current UDP or datagram unix domain socket object.\nIn case of success, it returns 1. Otherwise, it returns nil and a string describing the error.\nThe input argument data can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.\nThis feature was first introduced in the v0.5.7 release.\nBack to TOC\nudpsock:receive syntax: data, err = udpsock:receive(size?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nReceives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, size.\nThis method is a synchronous operation and is 100% nonblocking.\nIn case of success, it returns the data received; in case of error, it returns nil with a string describing the error.\nIf the size argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than 8192, then 8192 will be used instead.\nIf no argument is specified, then the maximal buffer size, 8192 is assumed.\nTimeout for the reading operation is controlled by the lua_socket_read_timeout config directive and the settimeout method. And the latter takes priority. For example:\nsock:settimeout(1000) -- one second timeout local data, err = sock:receive() if not data then ngx.say(\u0026#34;failed to read a packet: \u0026#34;, err) return end ngx.say(\u0026#34;successfully read a packet: \u0026#34;, data) It is important here to call the settimeout method before calling this method.\nThis feature was first introduced in the v0.5.7 release.\nBack to TOC\nudpsock:close syntax: ok, err = udpsock:close()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nCloses the current UDP or datagram unix domain socket. It returns the 1 in case of success and returns nil with a string describing the error otherwise.\nSocket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.\nThis feature was first introduced in the v0.5.7 release.\nBack to TOC\nudpsock:settimeout syntax: udpsock:settimeout(time)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nSet the timeout value in milliseconds for subsequent socket operations (like receive).\nSettings done by this method takes priority over those config directives, like lua_socket_read_timeout.\nThis feature was first introduced in the v0.5.7 release.\nBack to TOC\nngx.socket.stream Just an alias to ngx.socket.tcp. If the stream-typed cosocket may also connect to a unix domain socket, then this API name is preferred.\nThis API function was first added to the v0.10.1 release.\nBack to TOC\nngx.socket.tcp syntax: tcpsock = ngx.socket.tcp()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nCreates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the \u0026ldquo;cosocket\u0026rdquo; objects). The following methods are supported on this object:\n connect sslhandshake send receive close settimeout settimeouts setoption receiveany receiveuntil setkeepalive getreusedtimes  It is intended to be compatible with the TCP API of the LuaSocket library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.\nThe cosocket object created by this API function has exactly the same lifetime as the Lua handler creating it. So never pass the cosocket object to any other Lua handler (including ngx.timer callback functions) and never share the cosocket object between different NGINX requests.\nFor every cosocket object\u0026rsquo;s underlying connection, if you do not explicitly close it (via close) or put it back to the connection pool (via setkeepalive), then it is automatically closed when one of the following two events happens:\n the current request handler completes, or the Lua cosocket object value gets collected by the Lua GC.  Fatal errors in cosocket operations always automatically close the current connection (note that, read timeout error is the only error that is not fatal), and if you call close on a closed connection, you will get the \u0026ldquo;closed\u0026rdquo; error.\nStarting from the 0.9.9 release, the cosocket object here is full-duplex, that is, a reader \u0026ldquo;light thread\u0026rdquo; and a writer \u0026ldquo;light thread\u0026rdquo; can operate on a single cosocket object simultaneously (both \u0026ldquo;light threads\u0026rdquo; must belong to the same Lua handler though, see reasons above). But you cannot have two \u0026ldquo;light threads\u0026rdquo; both reading (or writing or connecting) the same cosocket, otherwise you might get an error like \u0026ldquo;socket busy reading\u0026rdquo; when calling the methods of the cosocket object.\nThis feature was first introduced in the v0.5.0rc1 release.\nSee also ngx.socket.udp.\nBack to TOC\ntcpsock:connect syntax: ok, err = tcpsock:connect(host, port, options_table?)\nsyntax: ok, err = tcpsock:connect(\u0026ldquo;unix:/path/to/unix-domain.socket\u0026rdquo;, options_table?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nAttempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.\nBefore actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the ngx.socket.connect function).\nBoth IP addresses and domain names can be specified as the host argument. In case of domain names, this method will use Nginx core\u0026rsquo;s dynamic resolver to parse the domain name without blocking and it is required to configure the resolver directive in the nginx.conf file like this:\nresolver 8.8.8.8; # use Google\u0026#39;s public DNS nameserver If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.\nIn case of error, the method returns nil followed by a string describing the error. In case of success, the method returns 1.\nHere is an example for connecting to a TCP server:\nlocation /test { resolver 8.8.8.8; content_by_lua_block { local sock = ngx.socket.tcp() local ok, err = sock:connect(\u0026#34;www.google.com\u0026#34;, 80) if not ok then ngx.say(\u0026#34;failed to connect to google: \u0026#34;, err) return end ngx.say(\u0026#34;successfully connected to google!\u0026#34;) sock:close() } } Connecting to a Unix Domain Socket file is also possible:\nlocal sock = ngx.socket.tcp() local ok, err = sock:connect(\u0026#34;unix:/tmp/memcached.sock\u0026#34;) if not ok then ngx.say(\u0026#34;failed to connect to the memcached unix domain socket: \u0026#34;, err) return end assuming memcached (or something else) is listening on the unix domain socket file /tmp/memcached.sock.\nTimeout for the connecting operation is controlled by the lua_socket_connect_timeout config directive and the settimeout method. And the latter takes priority. For example:\nlocal sock = ngx.socket.tcp() sock:settimeout(1000) -- one second timeout local ok, err = sock:connect(host, port) It is important here to call the settimeout method before calling this method.\nCalling this method on an already connected socket object will cause the original connection to be closed first.\nAn optional Lua table can be specified as the last argument to this method to specify various connect options:\n pool specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template \u0026quot;\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt;\u0026quot; or \u0026quot;\u0026lt;unix-socket-path\u0026gt;\u0026quot;.\n pool_size specify the size of the connection pool. If omitted and no backlog option was provided, no pool will be created. If omitted but backlog was provided, the pool will be created with a default size equal to the value of the lua_socket_pool_size directive. The connection pool holds up to pool_size alive connections ready to be reused by subsequent calls to connect, but note that there is no upper limit to the total number of opened connections outside of the pool. If you need to restrict the total number of opened connections, specify the backlog option. When the connection pool would exceed its size limit, the least recently used (kept-alive) connection already in the pool will be closed to make room for the current connection. Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process. Also note that the size of the connection pool cannot be changed once it has been created. This option was first introduced in the v0.10.14 release.\n backlog if specified, this module will limit the total number of opened connections for this pool. No more connections than pool_size can be opened for this pool at any time. If the connection pool is full, subsequent connect operations will be queued into a queue equal to this option\u0026rsquo;s value (the \u0026ldquo;backlog\u0026rdquo; queue). If the number of queued connect operations is equal to backlog, subsequent connect operations will fail and return nil plus the error string \u0026quot;too many waiting connect operations\u0026quot;. The queued connect operations will be resumed once the number of connections in the pool is less than pool_size. The queued connect operation will abort once they have been queued for more than connect_timeout, controlled by settimeouts, and will return nil plus the error string \u0026quot;timeout\u0026quot;. This option was first introduced in the v0.10.14 release.\n  The support for the options table argument was first introduced in the v0.5.7 release.\nThis method was first introduced in the v0.5.0rc1 release.\nBack to TOC\ntcpsock:sslhandshake syntax: session, err = tcpsock:sslhandshake(reused_session?, server_name?, ssl_verify?, send_status_req?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nDoes SSL/TLS handshake on the currently established connection.\nThe optional reused_session argument can take a former SSL session userdata returned by a previous sslhandshake call for exactly the same target. For short-lived connections, reusing SSL sessions can usually speed up the handshake by one order by magnitude but it is not so useful if the connection pool is enabled. This argument defaults to nil. If this argument takes the boolean false value, no SSL session userdata would return by this call and only a Lua boolean will be returned as the first return value; otherwise the current SSL session will always be returned as the first argument in case of successes.\nThe optional server_name argument is used to specify the server name for the new TLS extension Server Name Indication (SNI). Use of SNI can make different servers share the same IP address on the server side. Also, when SSL verification is enabled, this server_name argument is also used to validate the server name specified in the server certificate sent from the remote.\nThe optional ssl_verify argument takes a Lua boolean value to control whether to perform SSL verification. When set to true, the server certificate will be verified according to the CA certificates specified by the lua_ssl_trusted_certificate directive. You may also need to adjust the lua_ssl_verify_depth directive to control how deep we should follow along the certificate chain. Also, when the ssl_verify argument is true and the server_name argument is also specified, the latter will be used to validate the server name in the server certificate.\nThe optional send_status_req argument takes a boolean that controls whether to send the OCSP status request in the SSL handshake request (which is for requesting OCSP stapling).\nFor connections that have already done SSL/TLS handshake, this method returns immediately.\nThis method was first introduced in the v0.9.11 release.\nBack to TOC\ntcpsock:send syntax: bytes, err = tcpsock:send(data)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nSends data without blocking on the current TCP or Unix Domain Socket connection.\nThis method is a synchronous operation that will not return until all the data has been flushed into the system socket send buffer or an error occurs.\nIn case of success, it returns the total number of bytes that have been sent. Otherwise, it returns nil and a string describing the error.\nThe input argument data can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.\nTimeout for the sending operation is controlled by the lua_socket_send_timeout config directive and the settimeout method. And the latter takes priority. For example:\nsock:settimeout(1000) -- one second timeout local bytes, err = sock:send(request) It is important here to call the settimeout method before calling this method.\nIn case of any connection errors, this method always automatically closes the current connection.\nThis feature was first introduced in the v0.5.0rc1 release.\nBack to TOC\ntcpsock:receive syntax: data, err, partial = tcpsock:receive(size)\nsyntax: data, err, partial = tcpsock:receive(pattern?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nReceives data from the connected socket according to the reading pattern or size.\nThis method is a synchronous operation just like the send method and is 100% nonblocking.\nIn case of success, it returns the data received; in case of error, it returns nil with a string describing the error and the partial data received so far.\nIf a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.\nIf a non-number-like string argument is specified, then it is interpreted as a \u0026ldquo;pattern\u0026rdquo;. The following patterns are supported:\n '*a': reads from the socket until the connection is closed. No end-of-line translation is performed; '*l': reads a line of text from the socket. The line is terminated by a Line Feed (LF) character (ASCII 10), optionally preceded by a Carriage Return (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.  If no argument is specified, then it is assumed to be the pattern '*l', that is, the line reading pattern.\nTimeout for the reading operation is controlled by the lua_socket_read_timeout config directive and the settimeout method. And the latter takes priority. For example:\nsock:settimeout(1000) -- one second timeout local line, err, partial = sock:receive() if not line then ngx.say(\u0026#34;failed to read a line: \u0026#34;, err) return end ngx.say(\u0026#34;successfully read a line: \u0026#34;, line) It is important here to call the settimeout method before calling this method.\nSince the v0.8.8 release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.\nThis feature was first introduced in the v0.5.0rc1 release.\nBack to TOC\ntcpsock:receiveany syntax: data, err = tcpsock:receiveany(max)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nReturns any data received by the connected socket, at most max bytes.\nThis method is a synchronous operation just like the send method and is 100% nonblocking.\nIn case of success, it returns the data received; in case of error, it returns nil with a string describing the error.\nIf the received data is more than this size, this method will return with exactly this size of data. The remaining data in the underlying receive buffer could be returned in the next reading operation.\nTimeout for the reading operation is controlled by the lua_socket_read_timeout config directive and the settimeouts method. And the latter takes priority. For example:\nsock:settimeouts(1000, 1000, 1000) -- one second timeout for connect/read/write local data, err = sock:receiveany(10 * 1024) -- read any data, at most 10K if not data then ngx.say(\u0026#34;failed to read any data: \u0026#34;, err) return end ngx.say(\u0026#34;successfully read: \u0026#34;, data) This method doesn\u0026rsquo;t automatically close the current connection when the read timeout error occurs. For other connection errors, this method always automatically closes the connection.\nThis feature was first introduced in the v0.10.14 release.\nBack to TOC\ntcpsock:receiveuntil syntax: iterator = tcpsock:receiveuntil(pattern, options?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nThis method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.\nHere is an example for using this method to read a data stream with the boundary sequence --abcedhb:\nlocal reader = sock:receiveuntil(\u0026#34;\\r\\n--abcedhb\u0026#34;) local data, err, partial = reader() if not data then ngx.say(\u0026#34;failed to read the data stream: \u0026#34;, err) end ngx.say(\u0026#34;read the data stream: \u0026#34;, data) When called without any argument, the iterator function returns the received data right before the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is 'hello, world! -agentzh\\r\\n--abcedhb blah blah', then the string 'hello, world! -agentzh' will be returned.\nIn case of error, the iterator function will return nil along with a string describing the error and the partial data bytes that have been read so far.\nThe iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.\nThe iterator function behaves differently (i.e., like a real iterator) when it is called with a size argument. That is, it will read that size of data on each invocation and will return nil at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the err return value will be nil too. The iterator function will be reset after the last successful invocation that returns nil data and nil error. Consider the following example:\nlocal reader = sock:receiveuntil(\u0026#34;\\r\\n--abcedhb\u0026#34;) while true do local data, err, partial = reader(4) if not data then if err then ngx.say(\u0026#34;failed to read the data stream: \u0026#34;, err) break end ngx.say(\u0026#34;read done\u0026#34;) break end ngx.say(\u0026#34;read chunk: [\u0026#34;, data, \u0026#34;]\u0026#34;) end Then for the incoming data stream 'hello, world! -agentzh\\r\\n--abcedhb blah blah', we shall get the following output from the sample code above:\nread chunk: [hell] read chunk: [o, w] read chunk: [orld] read chunk: [! -a] read chunk: [gent] read chunk: [zh] read done  Note that, the actual data returned might be a little longer than the size limit specified by the size argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.\nTimeout for the iterator function\u0026rsquo;s reading operation is controlled by the lua_socket_read_timeout config directive and the settimeout method. And the latter takes priority. For example:\nlocal readline = sock:receiveuntil(\u0026#34;\\r\\n\u0026#34;) sock:settimeout(1000) -- one second timeout line, err, partial = readline() if not line then ngx.say(\u0026#34;failed to read a line: \u0026#34;, err) return end ngx.say(\u0026#34;successfully read a line: \u0026#34;, line) It is important here to call the settimeout method before calling the iterator function (note that the receiveuntil call is irrelevant here).\nAs from the v0.5.1 release, this method also takes an optional options table argument to control the behavior. The following options are supported:\n inclusive  The inclusive takes a boolean value to control whether to include the pattern string in the returned data string. Default to false. For example,\nlocal reader = tcpsock:receiveuntil(\u0026#34;_END_\u0026#34;, { inclusive = true }) local data = reader() ngx.say(data) Then for the input data stream \u0026quot;hello world _END_ blah blah blah\u0026quot;, then the example above will output hello world _END_, including the pattern string _END_ itself.\nSince the v0.8.8 release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.\nThis method was first introduced in the v0.5.0rc1 release.\nBack to TOC\ntcpsock:close syntax: ok, err = tcpsock:close()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nCloses the current TCP or stream unix domain socket. It returns the 1 in case of success and returns nil with a string describing the error otherwise.\nNote that there is no need to call this method on socket objects that have invoked the setkeepalive method because the socket object is already closed (and the current connection is saved into the built-in connection pool).\nSocket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.\nThis feature was first introduced in the v0.5.0rc1 release.\nBack to TOC\ntcpsock:settimeout syntax: tcpsock:settimeout(time)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nSet the timeout value in milliseconds for subsequent socket operations (connect, receive, and iterators returned from receiveuntil).\nSettings done by this method takes priority over those config directives, i.e., lua_socket_connect_timeout, lua_socket_send_timeout, and lua_socket_read_timeout.\nNote that this method does not affect the lua_socket_keepalive_timeout setting; the timeout argument to the setkeepalive method should be used for this purpose instead.\nThis feature was first introduced in the v0.5.0rc1 release.\nBack to TOC\ntcpsock:settimeouts syntax: tcpsock:settimeouts(connect_timeout, send_timeout, read_timeout)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nSets the connect timeout thresold, send timeout threshold, and read timeout threshold, respetively, in milliseconds, for subsequent socket operations (connect, send, receive, and iterators returned from receiveuntil).\nSettings done by this method takes priority over those config directives, i.e., lua_socket_connect_timeout, lua_socket_send_timeout, and lua_socket_read_timeout.\nYou are recommended to use settimeouts instead of settimeout.\nNote that this method does not affect the lua_socket_keepalive_timeout setting; the timeout argument to the setkeepalive method should be used for this purpose instead.\nThis feature was first introduced in the v0.10.7 release.\nBack to TOC\ntcpsock:setoption syntax: tcpsock:setoption(option, value?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nThis function is added for LuaSocket API compatibility and does nothing for now. Its functionality will be implemented in future.\nThis feature was first introduced in the v0.5.0rc1 release.\nBack to TOC\ntcpsock:setkeepalive syntax: ok, err = tcpsock:setkeepalive(timeout?, size?)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nPuts the current socket\u0026rsquo;s connection immediately into the cosocket built-in connection pool and keep it alive until other connect method calls request it or the associated maximal idle timeout is expired.\nThe first optional argument, timeout, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the lua_socket_keepalive_timeout config directive will be used. If the 0 value is given, then the timeout interval is unlimited.\nThe second optional argument size is considered deprecated since the v0.10.14 release of this module, in favor of the pool_size option of the connect method. Since the v0.10.14 release, this option will only take effect if the call to connect did not already create a connection pool. When this option takes effect (no connection pool was previously created by connect), it will specify the size of the connection pool, and create it. If omitted (and no pool was previously created), the default size is the value of the lua_socket_pool_size directive. The connection pool holds up to size alive connections ready to be reused by subsequent calls to connect, but note that there is no upper limit to the total number of opened connections outside of the pool. When the connection pool would exceed its size limit, the least recently used (kept-alive) connection already in the pool will be closed to make room for the current connection. Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process. Also note that the size of the connection pool cannot be changed once it has been created. If you need to restrict the total number of opened connections, specify both the pool_size and backlog option in the call to connect.\nIn case of success, this method returns 1; otherwise, it returns nil and a string describing the error.\nWhen the system receive buffer for the current connection has unread data, then this method will return the \u0026ldquo;connection in dubious state\u0026rdquo; error message (as the second return value) because the previous session has unread data left behind for the next session and the connection is not safe to be reused.\nThis method also makes the current cosocket object enter the \u0026ldquo;closed\u0026rdquo; state, so there is no need to manually call the close method on it afterwards.\nThis feature was first introduced in the v0.5.0rc1 release.\nBack to TOC\ntcpsock:getreusedtimes syntax: count, err = tcpsock:getreusedtimes()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nThis method returns the (successfully) reused times for the current connection. In case of error, it returns nil and a string describing the error.\nIf the current connection does not come from the built-in connection pool, then this method always returns 0, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.\nThis feature was first introduced in the v0.5.0rc1 release.\nBack to TOC\nngx.socket.connect syntax: tcpsock, err = ngx.socket.connect(host, port)\nsyntax: tcpsock, err = ngx.socket.connect(\u0026ldquo;unix:/path/to/unix-domain.socket\u0026rdquo;)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;\nThis function is a shortcut for combining ngx.socket.tcp() and the connect() method call in a single operation. It is actually implemented like this:\nlocal sock = ngx.socket.tcp() local ok, err = sock:connect(...) if not ok then return nil, err end return sock There is no way to use the settimeout method to specify connecting timeout for this method and the lua_socket_connect_timeout directive must be set at configure time instead.\nThis feature was first introduced in the v0.5.0rc1 release.\nBack to TOC\nngx.get_phase syntax: str = ngx.get_phase()\ncontext: init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nRetrieves the current running phase name. Possible return values are\n init for the context of init_by_lua*. init_worker for the context of init_worker_by_lua*. ssl_cert for the context of ssl_certificate_by_lua*. ssl_session_fetch for the context of ssl_session_fetch_by_lua*. ssl_session_store for the context of ssl_session_store_by_lua*. set for the context of set_by_lua*. rewrite for the context of rewrite_by_lua*. balancer for the context of balancer_by_lua*. access for the context of access_by_lua*. content for the context of content_by_lua*. header_filter for the context of header_filter_by_lua*. body_filter for the context of body_filter_by_lua*. log for the context of log_by_lua*. timer for the context of user callback functions for ngx.timer.*.  This API was first introduced in the v0.5.10 release.\nBack to TOC\nngx.thread.spawn syntax: co = ngx.thread.spawn(func, arg1, arg2, \u0026hellip;)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nSpawns a new user \u0026ldquo;light thread\u0026rdquo; with the Lua function func as well as those optional arguments arg1, arg2, and etc. Returns a Lua thread (or Lua coroutine) object represents this \u0026ldquo;light thread\u0026rdquo;.\n\u0026ldquo;Light threads\u0026rdquo; are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.\nBefore ngx.thread.spawn returns, the func will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the Nginx API for Lua (like tcpsock:receive).\nAfter ngx.thread.spawn returns, the newly-created \u0026ldquo;light thread\u0026rdquo; will keep running asynchronously usually at various I/O events.\nAll the Lua code chunks running by rewrite_by_lua, access_by_lua, and content_by_lua are in a boilerplate \u0026ldquo;light thread\u0026rdquo; created automatically by ngx_lua. Such boilerplate \u0026ldquo;light thread\u0026rdquo; are also called \u0026ldquo;entry threads\u0026rdquo;.\nBy default, the corresponding Nginx handler (e.g., rewrite_by_lua handler) will not terminate until\n both the \u0026ldquo;entry thread\u0026rdquo; and all the user \u0026ldquo;light threads\u0026rdquo; terminates, a \u0026ldquo;light thread\u0026rdquo; (either the \u0026ldquo;entry thread\u0026rdquo; or a user \u0026ldquo;light thread\u0026rdquo; aborts by calling ngx.exit, ngx.exec, ngx.redirect, or ngx.req.set_uri(uri, true), or the \u0026ldquo;entry thread\u0026rdquo; terminates with a Lua error.  When the user \u0026ldquo;light thread\u0026rdquo; terminates with a Lua error, however, it will not abort other running \u0026ldquo;light threads\u0026rdquo; like the \u0026ldquo;entry thread\u0026rdquo; does.\nDue to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running \u0026ldquo;light thread\u0026rdquo; that is pending on one ore more Nginx subrequests. You must call ngx.thread.wait to wait for those \u0026ldquo;light thread\u0026rdquo; to terminate before quitting the \u0026ldquo;world\u0026rdquo;. A notable exception here is that you can abort pending subrequests by calling ngx.exit with and only with the status code ngx.ERROR (-1), 408, 444, or 499.\nThe \u0026ldquo;light threads\u0026rdquo; are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A \u0026ldquo;light thread\u0026rdquo; will keep running exclusively on the CPU until\n a (nonblocking) I/O operation cannot be completed in a single run, it calls coroutine.yield to actively give up execution, or it is aborted by a Lua error or an invocation of ngx.exit, ngx.exec, ngx.redirect, or ngx.req.set_uri(uri, true).  For the first two cases, the \u0026ldquo;light thread\u0026rdquo; will usually be resumed later by the ngx_lua scheduler unless a \u0026ldquo;stop-the-world\u0026rdquo; event happens.\nUser \u0026ldquo;light threads\u0026rdquo; can create \u0026ldquo;light threads\u0026rdquo; themselves. And normal user coroutines created by coroutine.create can also create \u0026ldquo;light threads\u0026rdquo;. The coroutine (be it a normal Lua coroutine or a \u0026ldquo;light thread\u0026rdquo;) that directly spawns the \u0026ldquo;light thread\u0026rdquo; is called the \u0026ldquo;parent coroutine\u0026rdquo; for the \u0026ldquo;light thread\u0026rdquo; newly spawned.\nThe \u0026ldquo;parent coroutine\u0026rdquo; can call ngx.thread.wait to wait on the termination of its child \u0026ldquo;light thread\u0026rdquo;.\nYou can call coroutine.status() and coroutine.yield() on the \u0026ldquo;light thread\u0026rdquo; coroutines.\nThe status of the \u0026ldquo;light thread\u0026rdquo; coroutine can be \u0026ldquo;zombie\u0026rdquo; if\n the current \u0026ldquo;light thread\u0026rdquo; already terminates (either successfully or with an error), its parent coroutine is still alive, and its parent coroutine is not waiting on it with ngx.thread.wait.  The following example demonstrates the use of coroutine.yield() in the \u0026ldquo;light thread\u0026rdquo; coroutines to do manual time-slicing:\nlocal yield = coroutine.yield function f() local self = coroutine.running() ngx.say(\u0026#34;f 1\u0026#34;) yield(self) ngx.say(\u0026#34;f 2\u0026#34;) yield(self) ngx.say(\u0026#34;f 3\u0026#34;) end local self = coroutine.running() ngx.say(\u0026#34;0\u0026#34;) yield(self) ngx.say(\u0026#34;1\u0026#34;) ngx.thread.spawn(f) ngx.say(\u0026#34;2\u0026#34;) yield(self) ngx.say(\u0026#34;3\u0026#34;) yield(self) ngx.say(\u0026#34;4\u0026#34;) Then it will generate the output\n0 1 f 1 2 f 2 3 f 3 4  \u0026ldquo;Light threads\u0026rdquo; are mostly useful for making concurrent upstream requests in a single Nginx request handler, much like a generalized version of ngx.location.capture_multi that can work with all the Nginx API for Lua. The following example demonstrates parallel requests to MySQL, Memcached, and upstream HTTP services in a single Lua handler, and outputting the results in the order that they actually return (similar to Facebook\u0026rsquo;s BigPipe model):\n-- query mysql, memcached, and a remote http service at the same time, -- output the results in the order that they -- actually return the results. local mysql = require \u0026#34;resty.mysql\u0026#34; local memcached = require \u0026#34;resty.memcached\u0026#34; local function query_mysql() local db = mysql:new() db:connect{ host = \u0026#34;127.0.0.1\u0026#34;, port = 3306, database = \u0026#34;test\u0026#34;, user = \u0026#34;monty\u0026#34;, password = \u0026#34;mypass\u0026#34; } local res, err, errno, sqlstate = db:query(\u0026#34;select * from cats order by id asc\u0026#34;) db:set_keepalive(0, 100) ngx.say(\u0026#34;mysql done: \u0026#34;, cjson.encode(res)) end local function query_memcached() local memc = memcached:new() memc:connect(\u0026#34;127.0.0.1\u0026#34;, 11211) local res, err = memc:get(\u0026#34;some_key\u0026#34;) ngx.say(\u0026#34;memcached done: \u0026#34;, res) end local function query_http() local res = ngx.location.capture(\u0026#34;/my-http-proxy\u0026#34;) ngx.say(\u0026#34;http done: \u0026#34;, res.body) end ngx.thread.spawn(query_mysql) -- create thread 1 ngx.thread.spawn(query_memcached) -- create thread 2 ngx.thread.spawn(query_http) -- create thread 3 This API was first enabled in the v0.7.0 release.\nBack to TOC\nngx.thread.wait syntax: ok, res1, res2, \u0026hellip; = ngx.thread.wait(thread1, thread2, \u0026hellip;)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;\nWaits on one or more child \u0026ldquo;light threads\u0026rdquo; and returns the results of the first \u0026ldquo;light thread\u0026rdquo; that terminates (either successfully or with an error).\nThe arguments thread1, thread2, and etc are the Lua thread objects returned by earlier calls of ngx.thread.spawn.\nThe return values have exactly the same meaning as coroutine.resume, that is, the first value returned is a boolean value indicating whether the \u0026ldquo;light thread\u0026rdquo; terminates successfully or not, and subsequent values returned are the return values of the user Lua function that was used to spawn the \u0026ldquo;light thread\u0026rdquo; (in case of success) or the error object (in case of failure).\nOnly the direct \u0026ldquo;parent coroutine\u0026rdquo; can wait on its child \u0026ldquo;light thread\u0026rdquo;, otherwise a Lua exception will be raised.\nThe following example demonstrates the use of ngx.thread.wait and ngx.location.capture to emulate ngx.location.capture_multi:\nlocal capture = ngx.location.capture local spawn = ngx.thread.spawn local wait = ngx.thread.wait local say = ngx.say local function fetch(uri) return capture(uri) end local threads = { spawn(fetch, \u0026#34;/foo\u0026#34;), spawn(fetch, \u0026#34;/bar\u0026#34;), spawn(fetch, \u0026#34;/baz\u0026#34;) } for i = 1, #threads do local ok, res = wait(threads[i]) if not ok then say(i, \u0026#34;: failed to run: \u0026#34;, res) else say(i, \u0026#34;: status: \u0026#34;, res.status) say(i, \u0026#34;: body: \u0026#34;, res.body) end end Here it essentially implements the \u0026ldquo;wait all\u0026rdquo; model.\nAnd below is an example demonstrating the \u0026ldquo;wait any\u0026rdquo; model:\nfunction f() ngx.sleep(0.2) ngx.say(\u0026#34;f: hello\u0026#34;) return \u0026#34;f done\u0026#34; end function g() ngx.sleep(0.1) ngx.say(\u0026#34;g: hello\u0026#34;) return \u0026#34;g done\u0026#34; end local tf, err = ngx.thread.spawn(f) if not tf then ngx.say(\u0026#34;failed to spawn thread f: \u0026#34;, err) return end ngx.say(\u0026#34;f thread created: \u0026#34;, coroutine.status(tf)) local tg, err = ngx.thread.spawn(g) if not tg then ngx.say(\u0026#34;failed to spawn thread g: \u0026#34;, err) return end ngx.say(\u0026#34;g thread created: \u0026#34;, coroutine.status(tg)) ok, res = ngx.thread.wait(tf, tg) if not ok then ngx.say(\u0026#34;failed to wait: \u0026#34;, res) return end ngx.say(\u0026#34;res: \u0026#34;, res) -- stop the \u0026#34;world\u0026#34;, aborting other running threads ngx.exit(ngx.OK) And it will generate the following output:\nf thread created: running g thread created: running g: hello res: g done  This API was first enabled in the v0.7.0 release.\nBack to TOC\nngx.thread.kill syntax: ok, err = ngx.thread.kill(thread)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, ngx.timer.\u0026#42;\nKills a running \u0026ldquo;light thread\u0026rdquo; created by ngx.thread.spawn. Returns a true value when successful or nil and a string describing the error otherwise.\nAccording to the current implementation, only the parent coroutine (or \u0026ldquo;light thread\u0026rdquo;) can kill a thread. Also, a running \u0026ldquo;light thread\u0026rdquo; with pending NGINX subrequests (initiated by ngx.location.capture for example) cannot be killed due to a limitation in the NGINX core.\nThis API was first enabled in the v0.9.9 release.\nBack to TOC\nngx.on_abort syntax: ok, err = ngx.on_abort(callback)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;\nRegisters a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.\nReturns 1 if the callback is registered successfully or returns nil and a string describing the error otherwise.\nAll the Nginx API for Lua can be used in the callback function because the function is run in a special \u0026ldquo;light thread\u0026rdquo;, just as those \u0026ldquo;light threads\u0026rdquo; created by ngx.thread.spawn.\nThe callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling ngx.exit, for example,\nlocal function my_cleanup() -- custom cleanup work goes here, like cancelling a pending DB transaction -- now abort all the \u0026#34;light threads\u0026#34; running in the current request handler ngx.exit(499) end local ok, err = ngx.on_abort(my_cleanup) if not ok then ngx.log(ngx.ERR, \u0026#34;failed to register the on_abort callback: \u0026#34;, err) ngx.exit(500) end When lua_check_client_abort is set to off (which is the default), then this function call will always return the error message \u0026ldquo;lua_check_client_abort is off\u0026rdquo;.\nAccording to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message \u0026ldquo;duplicate call\u0026rdquo;.\nThis API was first introduced in the v0.7.4 release.\nSee also lua_check_client_abort.\nBack to TOC\nngx.timer.at syntax: hdl, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, \u0026hellip;)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nCreates an Nginx timer with a user callback function as well as optional user arguments.\nThe first argument, delay, specifies the delay for the timer, in seconds. One can specify fractional seconds like 0.001 to mean 1 millisecond here. 0 delay can also be specified, in which case the timer will immediately expire when the current handler yields execution.\nThe second argument, callback, can be any Lua function, which will be invoked later in a background \u0026ldquo;light thread\u0026rdquo; after the delay specified. The user callback will be called automatically by the Nginx core with the arguments premature, user_arg1, user_arg2, and etc, where the premature argument takes a boolean value indicating whether it is a premature timer expiration or not, and user_arg1, user_arg2, and etc, are those (extra) user arguments specified when calling ngx.timer.at as the remaining arguments.\nPremature timer expiration happens when the Nginx worker process is trying to shut down, as in an Nginx configuration reload triggered by the HUP signal or in an Nginx server shutdown. When the Nginx worker is trying to shut down, one can no longer call ngx.timer.at to create new timers with nonzero delays and in that case ngx.timer.at will return a \u0026ldquo;conditional false\u0026rdquo; value and a string describing the error, that is, \u0026ldquo;process exiting\u0026rdquo;.\nStarting from the v0.9.3 release, it is allowed to create zero-delay timers even when the Nginx worker process starts shutting down.\nWhen a timer expires, the user Lua code in the timer callback is running in a \u0026ldquo;light thread\u0026rdquo; detached completely from the original request creating the timer. So objects with the same lifetime as the request creating them, like cosockets, cannot be shared between the original request and the timer user callback function.\nHere is a simple example:\nlocation / { ... log_by_lua_block { local function push_data(premature, uri, args, status) -- push the data uri, args, and status to the remote -- via ngx.socket.tcp or ngx.socket.udp -- (one may want to buffer the data in Lua a bit to -- save I/O operations) end local ok, err = ngx.timer.at(0, push_data, ngx.var.uri, ngx.var.args, ngx.header.status) if not ok then ngx.log(ngx.ERR, \u0026#34;failed to create timer: \u0026#34;, err) return end } } One can also create infinite re-occurring timers, for instance, a timer getting triggered every 5 seconds, by calling ngx.timer.at recursively in the timer callback function. Here is such an example,\nlocal delay = 5 local handler handler = function (premature) -- do some routine job in Lua just like a cron job if premature then return end local ok, err = ngx.timer.at(delay, handler) if not ok then ngx.log(ngx.ERR, \u0026#34;failed to create the timer: \u0026#34;, err) return end end local ok, err = ngx.timer.at(delay, handler) if not ok then ngx.log(ngx.ERR, \u0026#34;failed to create the timer: \u0026#34;, err) return end It is recommended, however, to use the ngx.timer.every API function instead for creating recurring timers since it is more robust.\nBecause timer callbacks run in the background and their running time will not add to any client request\u0026rsquo;s response time, they can easily accumulate in the server and exhaust system resources due to either Lua programming mistakes or just too much client traffic. To prevent extreme consequences like crashing the Nginx server, there are built-in limitations on both the number of \u0026ldquo;pending timers\u0026rdquo; and the number of \u0026ldquo;running timers\u0026rdquo; in an Nginx worker process. The \u0026ldquo;pending timers\u0026rdquo; here mean timers that have not yet been expired and \u0026ldquo;running timers\u0026rdquo; are those whose user callbacks are currently running.\nThe maximal number of pending timers allowed in an Nginx worker is controlled by the lua_max_pending_timers directive. The maximal number of running timers is controlled by the lua_max_running_timers directive.\nAccording to the current implementation, each \u0026ldquo;running timer\u0026rdquo; will take one (fake) connection record from the global connection record list configured by the standard worker_connections directive in nginx.conf. So ensure that the worker_connections directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks (as limited by the lua_max_running_timers directive).\nA lot of the Lua APIs for Nginx are enabled in the context of the timer callbacks, like stream/datagram cosockets (ngx.socket.tcp and ngx.socket.udp), shared memory dictionaries (ngx.shared.DICT), user coroutines (coroutine.*), user \u0026ldquo;light threads\u0026rdquo; (ngx.thread.*), ngx.exit, ngx.now/ngx.time, ngx.md5/ngx.sha1_bin, are all allowed. But the subrequest API (like ngx.location.capture), the ngx.req.* API, the downstream output API (like ngx.say, ngx.print, and ngx.flush) are explicitly disabled in this context.\nYou can pass most of the standard Lua values (nils, booleans, numbers, strings, tables, closures, file handles, and etc) into the timer callback, either explicitly as user arguments or implicitly as upvalues for the callback closure. There are several exceptions, however: you cannot pass any thread objects returned by coroutine.create and ngx.thread.spawn or any cosocket objects returned by ngx.socket.tcp, ngx.socket.udp, and ngx.req.socket because these objects\u0026rsquo; lifetime is bound to the request context creating them while the timer callback is detached from the creating request\u0026rsquo;s context (by design) and runs in its own (fake) request context. If you try to share the thread or cosocket objects across the boundary of the creating request, then you will get the \u0026ldquo;no co ctx found\u0026rdquo; error (for threads) or \u0026ldquo;bad request\u0026rdquo; (for cosockets). It is fine, however, to create all these objects inside your timer callback.\nThis API was first introduced in the v0.8.0 release.\nBack to TOC\nngx.timer.every syntax: hdl, err = ngx.timer.every(delay, callback, user_arg1, user_arg2, \u0026hellip;)\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSimilar to the ngx.timer.at API function, but\n delay cannot be zero, timer will be created every delay seconds until the current Nginx worker process starts exiting.  When success, returns a \u0026ldquo;conditional true\u0026rdquo; value (but not a true). Otherwise, returns a \u0026ldquo;conditional false\u0026rdquo; value and a string describing the error.\nThis API also respect the lua_max_pending_timers and lua_max_running_timers.\nThis API was first introduced in the v0.10.9 release.\nBack to TOC\nngx.timer.running_count syntax: count = ngx.timer.running_count()\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the number of timers currently running.\nThis directive was first introduced in the v0.9.20 release.\nBack to TOC\nngx.timer.pending_count syntax: count = ngx.timer.pending_count()\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nReturns the number of pending timers.\nThis directive was first introduced in the v0.9.20 release.\nBack to TOC\nngx.config.subsystem syntax: subsystem = ngx.config.subsystem\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;\nThis string field indicates the current NGINX subsystem the current Lua environment is based on. For this module, this field always takes the string value \u0026quot;http\u0026quot;. For ngx_stream_lua_module, however, this field takes the value \u0026quot;stream\u0026quot;.\nThis field was first introduced in the 0.10.1.\nBack to TOC\nngx.config.debug syntax: debug = ngx.config.debug\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;\nThis boolean field indicates whether the current Nginx is a debug build, i.e., being built by the ./configure option --with-debug.\nThis field was first introduced in the 0.8.7.\nBack to TOC\nngx.config.prefix syntax: prefix = ngx.config.prefix()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;\nReturns the Nginx server \u0026ldquo;prefix\u0026rdquo; path, as determined by the -p command-line option when running the nginx executable, or the path specified by the --prefix command-line option when building Nginx with the ./configure script.\nThis function was first introduced in the 0.9.2.\nBack to TOC\nngx.config.nginx_version syntax: ver = ngx.config.nginx_version\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;\nThis field take an integral value indicating the version number of the current Nginx core being used. For example, the version number 1.4.3 results in the Lua number 1004003.\nThis API was first introduced in the 0.9.3 release.\nBack to TOC\nngx.config.nginx_configure syntax: str = ngx.config.nginx_configure()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;\nThis function returns a string for the NGINX ./configure command\u0026rsquo;s arguments string.\nThis API was first introduced in the 0.9.5 release.\nBack to TOC\nngx.config.ngx_lua_version syntax: ver = ngx.config.ngx_lua_version\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;\nThis field take an integral value indicating the version number of the current ngx_lua module being used. For example, the version number 0.9.3 results in the Lua number 9003.\nThis API was first introduced in the 0.9.3 release.\nBack to TOC\nngx.worker.exiting syntax: exiting = ngx.worker.exiting()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;\nThis function returns a boolean value indicating whether the current Nginx worker process already starts exiting. Nginx worker process exiting happens on Nginx server quit or configuration reload (aka HUP reload).\nThis API was first introduced in the 0.9.3 release.\nBack to TOC\nngx.worker.pid syntax: pid = ngx.worker.pid()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;\nThis function returns a Lua number for the process ID (PID) of the current Nginx worker process. This API is more efficient than ngx.var.pid and can be used in contexts where the ngx.var.VARIABLE API cannot be used (like init_worker_by_lua).\nThis API was first introduced in the 0.9.5 release.\nBack to TOC\nngx.worker.count syntax: count = ngx.worker.count()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_by_lua\u0026#42;, init_worker_by_lua\u0026#42;\nReturns the total number of the Nginx worker processes (i.e., the value configured by the worker_processes directive in nginx.conf).\nThis API was first introduced in the 0.9.20 release.\nBack to TOC\nngx.worker.id syntax: count = ngx.worker.id()\ncontext: set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, init_worker_by_lua\u0026#42;\nReturns the ordinal number of the current Nginx worker processes (starting from number 0).\nSo if the total number of workers is N, then this method may return a number between 0 and N - 1 (inclusive).\nThis function returns meaningful values only for NGINX 1.9.1+. With earlier versions of NGINX, it always returns nil.\nSee also ngx.worker.count.\nThis API was first introduced in the 0.9.20 release.\nBack to TOC\nngx.semaphore syntax: local semaphore = require \u0026ldquo;ngx.semaphore\u0026rdquo;\nThis is a Lua module that implements a classic-style semaphore API for efficient synchronizations among different \u0026ldquo;light threads\u0026rdquo;. Sharing the same semaphore among different \u0026ldquo;light threads\u0026rdquo; created in different (request) contexts are also supported as long as the \u0026ldquo;light threads\u0026rdquo; reside in the same NGINX worker process and the lua_code_cache directive is turned on (which is the default).\nThis Lua module does not ship with this ngx_lua module itself rather it is shipped with the lua-resty-core library.\nPlease refer to the documentation for this ngx.semaphore Lua module in lua-resty-core for more details.\nThis feature requires at least ngx_lua v0.10.0.\nBack to TOC\nngx.balancer syntax: local balancer = require \u0026ldquo;ngx.balancer\u0026rdquo;\nThis is a Lua module that provides a Lua API to allow defining completely dynamic load balancers in pure Lua.\nThis Lua module does not ship with this ngx_lua module itself rather it is shipped with the lua-resty-core library.\nPlease refer to the documentation for this ngx.balancer Lua module in lua-resty-core for more details.\nThis feature requires at least ngx_lua v0.10.0.\nBack to TOC\nngx.ssl syntax: local ssl = require \u0026ldquo;ngx.ssl\u0026rdquo;\nThis Lua module provides API functions to control the SSL handshake process in contexts like ssl_certificate_by_lua*.\nThis Lua module does not ship with this ngx_lua module itself rather it is shipped with the lua-resty-core library.\nPlease refer to the documentation for this ngx.ssl Lua module for more details.\nThis feature requires at least ngx_lua v0.10.0.\nBack to TOC\nngx.ocsp syntax: local ocsp = require \u0026ldquo;ngx.ocsp\u0026rdquo;\nThis Lua module provides API to perform OCSP queries, OCSP response validations, and OCSP stapling planting.\nUsually, this module is used together with the ngx.ssl module in the context of ssl_certificate_by_lua*.\nThis Lua module does not ship with this ngx_lua module itself rather it is shipped with the lua-resty-core library.\nPlease refer to the documentation for this ngx.ocsp Lua module for more details.\nThis feature requires at least ngx_lua v0.10.0.\nBack to TOC\nndk.set_var.DIRECTIVE syntax: res = ndk.set_var.DIRECTIVE_NAME\ncontext: init_worker_by_lua\u0026#42;, set_by_lua\u0026#42;, rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, log_by_lua\u0026#42;, ngx.timer.\u0026#42;, balancer_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nThis mechanism allows calling other nginx C modules\u0026rsquo; directives that are implemented by Nginx Devel Kit (NDK)\u0026rsquo;s set_var submodule\u0026rsquo;s ndk_set_var_value.\nFor example, the following set-misc-nginx-module directives can be invoked this way:\n set_quote_sql_str set_quote_pgsql_str set_quote_json_str set_unescape_uri set_escape_uri set_encode_base32 set_decode_base32 set_encode_base64 set_decode_base64 set_encode_hex set_decode_hex set_sha1 set_md5  For instance,\nlocal res = ndk.set_var.set_escape_uri(\u0026#39;a/b\u0026#39;); -- now res == \u0026#39;a%2fb\u0026#39; Similarly, the following directives provided by encrypted-session-nginx-module can be invoked from within Lua too:\n set_encrypt_session set_decrypt_session  This feature requires the ngx_devel_kit module.\nBack to TOC\ncoroutine.create syntax: co = coroutine.create(f)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, init_by_lua\u0026#42;, ngx.timer.\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nCreates a user Lua coroutines with a Lua function, and returns a coroutine object.\nSimilar to the standard Lua coroutine.create API, but works in the context of the Lua coroutines created by ngx_lua.\nThis API was first usable in the context of init_by_lua* since the 0.9.2.\nThis API was first introduced in the v0.6.0 release.\nBack to TOC\ncoroutine.resume syntax: ok, \u0026hellip; = coroutine.resume(co, \u0026hellip;)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, init_by_lua\u0026#42;, ngx.timer.\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nResumes the executation of a user Lua coroutine object previously yielded or just created.\nSimilar to the standard Lua coroutine.resume API, but works in the context of the Lua coroutines created by ngx_lua.\nThis API was first usable in the context of init_by_lua* since the 0.9.2.\nThis API was first introduced in the v0.6.0 release.\nBack to TOC\ncoroutine.yield syntax: \u0026hellip; = coroutine.yield(\u0026hellip;)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, init_by_lua\u0026#42;, ngx.timer.\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nYields the execution of the current user Lua coroutine.\nSimilar to the standard Lua coroutine.yield API, but works in the context of the Lua coroutines created by ngx_lua.\nThis API was first usable in the context of init_by_lua* since the 0.9.2.\nThis API was first introduced in the v0.6.0 release.\nBack to TOC\ncoroutine.wrap syntax: co = coroutine.wrap(f)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, init_by_lua\u0026#42;, ngx.timer.\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nSimilar to the standard Lua coroutine.wrap API, but works in the context of the Lua coroutines created by ngx_lua.\nThis API was first usable in the context of init_by_lua* since the 0.9.2.\nThis API was first introduced in the v0.6.0 release.\nBack to TOC\ncoroutine.running syntax: co = coroutine.running()\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, init_by_lua\u0026#42;, ngx.timer.\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nIdentical to the standard Lua coroutine.running API.\nThis API was first usable in the context of init_by_lua* since the 0.9.2.\nThis API was first enabled in the v0.6.0 release.\nBack to TOC\ncoroutine.status syntax: status = coroutine.status(co)\ncontext: rewrite_by_lua\u0026#42;, access_by_lua\u0026#42;, content_by_lua\u0026#42;, init_by_lua\u0026#42;, ngx.timer.\u0026#42;, header_filter_by_lua\u0026#42;, body_filter_by_lua\u0026#42;, ssl_certificate_by_lua\u0026#42;, ssl_session_fetch_by_lua\u0026#42;, ssl_session_store_by_lua\u0026#42;\nIdentical to the standard Lua coroutine.status API.\nThis API was first usable in the context of init_by_lua* since the 0.9.2.\nThis API was first enabled in the v0.6.0 release.\nBack to TOC\nObsolete Sections This section is just holding obsolete documentation sections that have been either renamed or removed so that existing links over the web are still valid.\nBack to TOC\nSpecial PCRE Sequences This section has been renamed to Special Escaping Sequences.\n"
},
{
	"uri": "/categories/xxxx/",
	"title": "xxxx",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/xxxxx/",
	"title": "xxxxx",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/2019/07/start/",
	"title": "Start",
	"tags": ["xxxxx"],
	"description": "",
	"content": " lua-resty-memcached lua-resty-mysql lua-resty-redis lua-resty-dns lua-resty-upload lua-resty-websocket lua-resty-lock lua-resty-logger-socket lua-resty-lrucache lua-resty-string ngx_memc ngx_postgres ngx_redis2 ngx_redis ngx_proxy ngx_fastcgi vvv  "
},
{
	"uri": "/2019/07/start/",
	"title": "Start",
	"tags": ["xxxxx"],
	"description": "",
	"content": " lua-resty-memcached lua-resty-mysql lua-resty-redis lua-resty-dns lua-resty-upload lua-resty-websocket lua-resty-lock lua-resty-logger-socket lua-resty-lrucache lua-resty-string ngx_memc ngx_postgres ngx_redis2 ngx_redis ngx_proxy ngx_fastcgi  "
},
{
	"uri": "/authors/",
	"title": "Authors",
	"tags": [],
	"description": "",
	"content": ""
}]